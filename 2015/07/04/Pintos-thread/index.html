<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Pintos_thread | ailin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在开始之前看了看深入浅出pintos，这里面有pintos用到的基本函数的说明，非常不错的。
入门阶段根据TA在实验中给出的第一部分提示，实现alarm-multiple嗯，因为TA在上面写得比较详细了。我就在这里略带一下,顺便看看整个程序走下来的思路就好了。
因为pintos这里有很多样例测试，一眼看过去的话，根本不知道何从下手，其实如果想比较快地知道这个样例测试的目的的话，有个比较快的方法：那">
<meta property="og:type" content="article">
<meta property="og:title" content="Pintos_thread">
<meta property="og:url" content="http://dengal3.github.com/2015/07/04/Pintos-thread/index.html">
<meta property="og:site_name" content="ailin">
<meta property="og:description" content="在开始之前看了看深入浅出pintos，这里面有pintos用到的基本函数的说明，非常不错的。
入门阶段根据TA在实验中给出的第一部分提示，实现alarm-multiple嗯，因为TA在上面写得比较详细了。我就在这里略带一下,顺便看看整个程序走下来的思路就好了。
因为pintos这里有很多样例测试，一眼看过去的话，根本不知道何从下手，其实如果想比较快地知道这个样例测试的目的的话，有个比较快的方法：那">
<meta property="og:image" content="/images/2015-07-04/alarm-priority.png">
<meta property="og:image" content="/images/2015-07-04/alarm-priority-1.png">
<meta property="og:image" content="/images/2015-07-04/alarm-priority-2.png">
<meta property="og:image" content="/images/2015-07-04/result-1.png">
<meta property="og:image" content="/images/2015-07-04/priority-change.png">
<meta property="og:image" content="/images/2015-07-04/result-2.png">
<meta property="og:image" content="/images/2015-07-04/priority-donate-one-1.png">
<meta property="og:image" content="/images/2015-07-04/priority-donate-one-2.png">
<meta property="og:image" content="/images/2015-07-04/priority-donate-one-3.png">
<meta property="og:image" content="/images/2015-07-04/priority-donate-result-1.png">
<meta property="og:image" content="/images/2015-07-04/priority-donate-improved-1.png">
<meta property="og:image" content="/images/2015-07-04/priority-donate-result-2.png">
<meta property="og:image" content="/images/2015-07-04/priority-donate-condvar.png">
<meta property="og:image" content="/images/2015-07-04/mlfqs-problem.png">
<meta property="og:image" content="/images/2015-07-04/mlfqs-result.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Pintos_thread">
<meta name="twitter:description" content="在开始之前看了看深入浅出pintos，这里面有pintos用到的基本函数的说明，非常不错的。
入门阶段根据TA在实验中给出的第一部分提示，实现alarm-multiple嗯，因为TA在上面写得比较详细了。我就在这里略带一下,顺便看看整个程序走下来的思路就好了。
因为pintos这里有很多样例测试，一眼看过去的话，根本不知道何从下手，其实如果想比较快地知道这个样例测试的目的的话，有个比较快的方法：那">
  
    <link rel="alternative" href="/atom.xml" title="ailin" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/logo.jpg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="images/logo.jpg" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ailin</a></h1>
		</hgroup>

		
		<p class="header-subtitle">其实这是流水账</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/dengal3" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1793490742" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/dengal" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Jquery/" style="font-size: 10px;">Jquery</a><a href="/tags/css/" style="font-size: 20px;">css</a><a href="/tags/hexo/" style="font-size: 10px;">hexo</a><a href="/tags/javascipt/" style="font-size: 10px;">javascipt</a><a href="/tags/javascript/" style="font-size: 20px;">javascript</a><a href="/tags/jekyll/" style="font-size: 10px;">jekyll</a><a href="/tags/js/" style="font-size: 10px;">js</a><a href="/tags/jsonp/" style="font-size: 10px;">jsonp</a><a href="/tags/nginx/" style="font-size: 10px;">nginx</a><a href="/tags/notes/" style="font-size: 10px;">notes</a><a href="/tags/object-oriented/" style="font-size: 10px;">object-oriented</a><a href="/tags/os/" style="font-size: 10px;">os</a><a href="/tags/pintos/" style="font-size: 20px;">pintos</a><a href="/tags/setTimeout/" style="font-size: 10px;">setTimeout</a><a href="/tags/thinking/" style="font-size: 20px;">thinking</a><a href="/tags/thread/" style="font-size: 10px;">thread</a><a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a><a href="/tags/假期/" style="font-size: 20px;">假期</a><a href="/tags/基本功/" style="font-size: 10px;">基本功</a><a href="/tags/外排序/" style="font-size: 10px;">外排序</a><a href="/tags/定时器/" style="font-size: 10px;">定时器</a><a href="/tags/布局/" style="font-size: 20px;">布局</a><a href="/tags/数据库/" style="font-size: 20px;">数据库</a><a href="/tags/日常/" style="font-size: 10px;">日常</a><a href="/tags/服务器/" style="font-size: 10px;">服务器</a><a href="/tags/树结构索引/" style="font-size: 10px;">树结构索引</a><a href="/tags/源码剖析/" style="font-size: 10px;">源码剖析</a><a href="/tags/笔记/" style="font-size: 10px;">笔记</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://daixuan.me">DX的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://54017.github.io">017的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">你希望能看到什么?</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ailin</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="images/logo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">ailin</h1>
			</hgroup>
			
			<p class="header-subtitle">其实这是流水账</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/dengal3" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1793490742" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/dengal" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-Pintos-thread" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/04/Pintos-thread/" class="article-date">
  	<time datetime="2015-07-04T02:18:11.000Z" itemprop="datePublished">2015-07-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Pintos_thread
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/os/">os</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pintos/">pintos</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在开始之前看了看<a href="http://wenku.baidu.com/view/3ecadb71f242336c1eb95ee1.html" target="_blank" rel="external">深入浅出pintos</a>，这里面有pintos用到的基本函数的说明，非常不错的。</p>
<h4 id="入门阶段">入门阶段</h4><p>根据TA在实验中给出的第一部分提示，实现alarm-multiple<br>嗯，因为TA在上面写得比较详细了。我就在这里略带一下,顺便看看整个程序走下来的思路就好了。</p>
<p>因为pintos这里有很多样例测试，一眼看过去的话，根本不知道何从下手，其实如果想比较快地知道这个样例测试的目的的话，有个比较快的方法：那就是看那个样例测试文件的前面的注释。</p>
<p>举个栗子:我想知道alarm-priority这个样例想让我们实现什么。那就打开<code>src/test/threads/alarm-priority.c</code><img src="/images/2015-07-04/alarm-priority.png" alt="alarm-priority"></p>
<p>然后综合一下样例对应的output还有result，就知道了这是希望我们当唤醒就绪列队中的线程时，我们总是让优先级高的线程先运行。</p>
<p>thread.c里有一个全局变量ready_list代表就绪线程，我们只要一直维持就绪线程有一个从高到低的优先级就好，在这里的话，主要就是在有ready_list的地方啦<br><img src="/images/2015-07-04/alarm-priority-1.png" alt="alarm-priority-1"><br><img src="/images/2015-07-04/alarm-priority-2.png" alt="alarm-priority-2"><br>这里主要是将list_push_back改为了list_insert_ordered，使队列成为有序的。我们要去看看list_insert_ordered的实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inserts ELEM in the proper position in LIST, which must be</span><br><span class="line">   sorted according to LESS given auxiliary data AUX.</span><br><span class="line">   Runs in O(n) average case in the number of elements in LIST. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">list_insert_ordered</span> <span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">struct</span> list_elem *elem,</span><br><span class="line">                     list_less_func *less, <span class="keyword">void</span> *aux)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> list_elem *e;</span><br><span class="line"></span><br><span class="line">  ASSERT (<span class="built_in">list</span> != NULL);</span><br><span class="line">  ASSERT (elem != NULL);</span><br><span class="line">  ASSERT (less != NULL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin (<span class="built_in">list</span>); e != list_end (<span class="built_in">list</span>); e = list_next (e))</span><br><span class="line">    <span class="keyword">if</span> (less (elem, e, aux))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">return</span> list_insert (e, elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要用到less函数作为排序的判断条件，这个是要我们自己实现的。这里要用到线程中的elem变量，还有list_entry，list_entry这个存在我觉得很有必要说清楚，因为之后在实现的过程中，这个东西就是起着很重要的作用。</p>
<p>一段有关list_entry的注释很好地解释了它的作用还有用法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Doubly linked list.</span><br><span class="line"></span><br><span class="line">   This implementation of a doubly linked list does not require</span><br><span class="line">   use of dynamically allocated memory.  Instead, each structure</span><br><span class="line">   that is a potential list element must embed a struct list_elem</span><br><span class="line">   member.  All of the list functions operate on these `struct</span><br><span class="line">   list_elem's.  The list_entry macro allows conversion from a</span><br><span class="line">   struct list_elem back to a structure object that contains it.</span><br><span class="line"></span><br><span class="line">   For example, suppose there is a needed for a list of `struct</span><br><span class="line">   foo'.  `struct foo' should contain a `struct list_elem'</span><br><span class="line">   member, like so:</span><br><span class="line"></span><br><span class="line">      struct foo</span><br><span class="line">        &#123;</span><br><span class="line">          struct list_elem elem;</span><br><span class="line">          int bar;</span><br><span class="line">          ...other members...</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">   Then a list of `struct foo' can be be declared and initialized</span><br><span class="line">   like so:</span><br><span class="line"></span><br><span class="line">      struct list foo_list;</span><br><span class="line"></span><br><span class="line">      list_init (&amp;foo_list);</span><br><span class="line"></span><br><span class="line">   Iteration is a typical situation where it is necessary to</span><br><span class="line">   convert from a struct list_elem back to its enclosing</span><br><span class="line">   structure.  Here's an example using foo_list:</span><br><span class="line"></span><br><span class="line">      struct list_elem *e;</span><br><span class="line"></span><br><span class="line">      for (e = list_begin (&amp;foo_list); e != list_end (&amp;foo_list);</span><br><span class="line">           e = list_next (e))</span><br><span class="line">        &#123;</span><br><span class="line">          struct foo *f = list_entry (e, struct foo, elem);</span><br><span class="line">          ...do something with f...</span><br><span class="line">        &#125;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>简单说来，list_entry就是一个很神奇的函数，你可以通过依次传入list_elem<em> elem，包含list_elem</em>的结构体，list_elem<em> 在结构体中的命名，来求出包含list_elem</em> elem对应的那个结构体的指针。</p>
<p>在less这个函数实现中elem是我们传的list<br>elem<em>,e是队列中的list_elem</em>,而我们想实现的是，如果elem的对应线程的优先级比e对应的线程的优先级要高时，就插到这个e的前面。具体代码实现如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************</span><br><span class="line">Function: cmp_thread_priority</span><br><span class="line"></span><br><span class="line">Description: 比较两个线程的优先级，如果前一个线程的优先级比后面的一个优先级高，则返回true，否则返回false</span><br><span class="line"></span><br><span class="line">Arguments: list_elem *, list_elem *, void *</span><br><span class="line"></span><br><span class="line">Output: bool</span><br><span class="line"></span><br><span class="line">************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_thread_priority</span> <span class="params">(<span class="keyword">struct</span> list_elem* a, <span class="keyword">struct</span> list_elem* b, <span class="keyword">void</span>* aux)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list_entry(a, <span class="keyword">struct</span> thread, elem)-&gt;priority &gt; list_entry(b, <span class="keyword">struct</span> thread, elem)-&gt;priority; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本来还有个地方是list_init(&amp;ready_list),这个不影响优先级的，所以不用改也ok。</p>
<p>然后我们就来<code>make clean</code>&amp;<code>make check</code>一下</p>
<p><img src="/images/2015-07-04/result-1.png" alt="result-1"></p>
<h4 id="正式开始">正式开始</h4><p>借着第一个测试样例的分析，我们来简单地过一下thread的基本知识还有函数。<br>首先，我们去看priority-change对应的测试样例代码（thread的测试样例代码都在<code>src/test/threads</code>文件夹下）<br><img src="/images/2015-07-04/priority-change.png" alt="priority-change"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">test_priority_change</span> <span class="params">(<span class="keyword">void</span>)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">/* This test does not work with the MLFQS. */</span></span><br><span class="line">  ASSERT (!thread_mlfqs);</span><br><span class="line"></span><br><span class="line">  msg (<span class="string">"Creating a high-priority thread 2."</span>);</span><br><span class="line">  thread_create (<span class="string">"thread 2"</span>, PRI_DEFAULT + <span class="number">1</span>, changing_thread, NULL);</span><br><span class="line">  msg (<span class="string">"Thread 2 should have just lowered its priority."</span>);</span><br><span class="line">  thread_set_priority (PRI_DEFAULT - <span class="number">2</span>);</span><br><span class="line">  msg (<span class="string">"Thread 2 should have just exited."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">changing_thread</span> <span class="params">(<span class="keyword">void</span> *aux UNUSED)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  msg (<span class="string">"Thread 2 now lowering priority."</span>);</span><br><span class="line">  thread_set_priority (PRI_DEFAULT - <span class="number">1</span>);</span><br><span class="line">  msg (<span class="string">"Thread 2 exiting."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ASSERT代表断言，就是指这里的thread_mlfqs一定是false的，不然就会报错。断言有助于我们找出代码出bug 的地方。<br><code>thread_create</code>函数在thread.c函数中实现,是用来创建新进程的。里面传的参数依次是线程的名字，线程的优先级，还有线程执行的函数，辅助参数。</p>
<p>分析之后发现，代码里面通过调用了<code>thread_create</code>函数创建了新进程，而且新进程的优先级是PRI_DEFAULT+1，比主线程的PRI_DEFAULT的还要高，所以会在主线程输出”Creating a high-priority thread 2.” 之后有线程Thread 2输出的”Thread 2 now lowering priority.”。所以我们在<code>thread_create</code>这个函数里面加入<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (priority &gt; thread_current()-&gt;priority) &#123;</span><br><span class="line">      thread_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>thread_set_priority</code>将本来是优先级最高的线程的优先级降低后，该线程就要马上放弃，重新加入到就绪列表中排队，然后重新调度，来确保在运行的是所有就绪队列中优先级最高的那个。所以我们直接在<code>thread_set_priority</code>函数里面加入<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_yield();</span><br></pre></td></tr></table></figure></p>
<p>嗯,然后我们就可以看到结果了。<br><img src="/images/2015-07-04/result-2.png" alt="result-2"><br>这个一起把priority-preemt还有priority-fifo一起给过了，非常好～</p>
<p>然后就进入<strong>donate</strong>部分。<br>因为donate部分的实现是整个实验的重点和难点部分，所以会比较详细的解释。</p>
<p>首先我们要知道优先级捐赠是什么意思，这个的话TA在pdf中的解释也比较清楚了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">假设任务1，任务2，任务3；他们的优先级顺序分别为1 &lt; 2 &lt; 3。有一个稀缺资源S，S由一个锁控制为互斥访问。</span><br><span class="line"></span><br><span class="line">任务1正在执行，并申请到了资源S；</span><br><span class="line">任务3抢占了任务1的执行，任务1挂起，任务3执行；</span><br><span class="line">任务3申请资源S，发现被占用，所以挂起，任务1恢复执行；</span><br><span class="line">任务2抢占了任务1的执行，任务1挂起，任务2执行；</span><br><span class="line">任务2执行完毕，任务1恢复；</span><br><span class="line">任务1释放资源S，任务3抢占资源S，任务3执行，任务1挂起；</span><br><span class="line">任务3执行完毕，任务1执行。</span><br><span class="line">以上可以看出，任务2虽然比任务3优先级低，但是比任务3优先执行。也就是说任务3的优先级被降低到了任务1的级别。</span><br><span class="line"></span><br><span class="line">     如何解决这个问题呢？最简单的思路就是一旦高优先级的任务因为低优先级任务占用资源而阻塞时，就将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级。</span><br><span class="line"></span><br><span class="line">这样的话上述过程中的2不能抢占任务1的执行，也就不会发生优先级反转，上述过程就是我们所说的优先级捐赠。</span><br></pre></td></tr></table></figure></p>
<p>首先我们来看看<code>priority-donate-one.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The main thread acquires a lock.  Then it creates two</span><br><span class="line">   higher-priority threads that block acquiring the lock, causing</span><br><span class="line">   them to donate their priorities to the main thread.  When the</span><br><span class="line">   main thread releases the lock, the other threads should</span><br><span class="line">   acquire it in priority order.</span><br><span class="line"></span><br><span class="line">   Based on a test originally submitted for Stanford's CS 140 in</span><br><span class="line">   winter 1999 by Matt Franklin &lt;startled@leland.stanford.edu&gt;,</span><br><span class="line">   Greg Hutchins &lt;gmh@leland.stanford.edu&gt;, Yu Ping Hu</span><br><span class="line">   &lt;yph@cs.stanford.edu&gt;.  Modified by arens. */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "tests/threads/tests.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "threads/init.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "threads/synch.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "threads/thread.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> thread_func acquire1_thread_func;</span><br><span class="line"><span class="keyword">static</span> thread_func acquire2_thread_func;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">test_priority_donate_one</span> <span class="params">(<span class="keyword">void</span>)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> lock lock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This test does not work with the MLFQS. */</span></span><br><span class="line">  ASSERT (!thread_mlfqs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure our priority is the default. */</span></span><br><span class="line">  ASSERT (thread_get_priority () == PRI_DEFAULT);</span><br><span class="line"></span><br><span class="line">  lock_init (&amp;lock);</span><br><span class="line">  lock_acquire (&amp;lock);</span><br><span class="line">  thread_create (<span class="string">"acquire1"</span>, PRI_DEFAULT + <span class="number">1</span>, acquire1_thread_func, &amp;lock);</span><br><span class="line">  msg (<span class="string">"This thread should have priority %d.  Actual priority: %d."</span>,</span><br><span class="line">       PRI_DEFAULT + <span class="number">1</span>, thread_get_priority ());</span><br><span class="line">  thread_create (<span class="string">"acquire2"</span>, PRI_DEFAULT + <span class="number">2</span>, acquire2_thread_func, &amp;lock);</span><br><span class="line">  msg (<span class="string">"This thread should have priority %d.  Actual priority: %d."</span>,</span><br><span class="line">       PRI_DEFAULT + <span class="number">2</span>, thread_get_priority ());</span><br><span class="line">  lock_release (&amp;lock);</span><br><span class="line">  msg (<span class="string">"acquire2, acquire1 must already have finished, in that order."</span>);</span><br><span class="line">  msg (<span class="string">"This should be the last line before finishing this test."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">acquire1_thread_func</span> <span class="params">(<span class="keyword">void</span> *lock_)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> lock *lock = lock_;</span><br><span class="line"></span><br><span class="line">  lock_acquire (lock);</span><br><span class="line">  msg (<span class="string">"acquire1: got the lock"</span>);</span><br><span class="line">  lock_release (lock);</span><br><span class="line">  msg (<span class="string">"acquire1: done"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">acquire2_thread_func</span> <span class="params">(<span class="keyword">void</span> *lock_)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> lock *lock = lock_;</span><br><span class="line"></span><br><span class="line">  lock_acquire (lock);</span><br><span class="line">  msg (<span class="string">"acquire2: got the lock"</span>);</span><br><span class="line">  lock_release (lock);</span><br><span class="line">  msg (<span class="string">"acquire2: done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>样例代码调用了<code>lock_init (&amp;lock)</code>,我们去看看相关的具体实现，lock相关部分的代码都在synch.c中</p>
<p>我们先去看看lock的结构体，相关的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lock. */</span></span><br><span class="line"><span class="keyword">struct</span> lock </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> thread *holder;      <span class="comment">/* Thread holding lock (for debugging). */</span></span><br><span class="line">    <span class="keyword">struct</span> semaphore semaphore; <span class="comment">/* Binary semaphore controlling access. */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A counting semaphore. */</span></span><br><span class="line"><span class="keyword">struct</span> semaphore </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> value;             <span class="comment">/* Current value. */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">list</span> waiters;        <span class="comment">/* List of waiting threads. */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>lock里面有个holder指针指向占有这个锁的线程，semaphore是信号量，这里也给出了它的实现，semaphore中有一个value，还有一个链表来记录在等待这个锁的线程。</p>
<p>lock_init(顾名思义，就是lock的初始化)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initializes LOCK.  A lock can be held by at most a single</span><br><span class="line">   thread at any given time.  Our locks are not "recursive", that</span><br><span class="line">   is, it is an error for the thread currently holding a lock to</span><br><span class="line">   try to acquire that lock.</span><br><span class="line"></span><br><span class="line">   A lock is a specialization of a semaphore with an initial</span><br><span class="line">   value of 1.  The difference between a lock and such a</span><br><span class="line">   semaphore is twofold.  First, a semaphore can have a value</span><br><span class="line">   greater than 1, but a lock can only be owned by a single</span><br><span class="line">   thread at a time.  Second, a semaphore does not have an owner,</span><br><span class="line">   meaning that one thread can "down" the semaphore and then</span><br><span class="line">   another one "up" it, but with a lock the same thread must both</span><br><span class="line">   acquire and release it.  When these restrictions prove</span><br><span class="line">   onerous, it's a good sign that a semaphore should be used,</span><br><span class="line">   instead of a lock. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">lock_init</span> <span class="params">(<span class="keyword">struct</span> lock *lock)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  ASSERT (lock != NULL);</span><br><span class="line"></span><br><span class="line">  lock-&gt;holder = NULL;</span><br><span class="line">  sema_init (&amp;lock-&gt;semaphore, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里先将锁的占有者设为NULL，然后在调用了个sema_init函数,看看sema_init的实现</p>
<p>sema_init(对信号量的初始化)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initializes semaphore SEMA to VALUE.  A semaphore is a</span><br><span class="line">   nonnegative integer along with two atomic operators for</span><br><span class="line">   manipulating it:</span><br><span class="line"></span><br><span class="line">   - down or "P": wait for the value to become positive, then</span><br><span class="line">     decrement it.</span><br><span class="line"></span><br><span class="line">   - up or "V": increment the value (and wake up one waiting</span><br><span class="line">     thread, if any). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">sema_init</span> <span class="params">(<span class="keyword">struct</span> semaphore *sema, <span class="keyword">unsigned</span> value)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  ASSERT (sema != NULL);</span><br><span class="line"></span><br><span class="line">  sema-&gt;value = value;</span><br><span class="line">  list_init (&amp;sema-&gt;waiters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据刚刚lock传的值，就知道在lock_init中sema_init将sema的value设为了1</p>
<p>然后，我们看一下在synch.c中的<code>lock_acquire</code>函数具体实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Acquires LOCK, sleeping until it becomes available if</span><br><span class="line">   necessary.  The lock must not already be held by the current</span><br><span class="line">   thread.</span><br><span class="line"></span><br><span class="line">   This function may sleep, so it must not be called within an</span><br><span class="line">   interrupt handler.  This function may be called with</span><br><span class="line">   interrupts disabled, but interrupts will be turned back on if</span><br><span class="line">   we need to sleep. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">lock_acquire</span> <span class="params">(<span class="keyword">struct</span> lock *lock)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  ASSERT (lock != NULL);</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line">  ASSERT (!lock_held_by_current_thread (lock));</span><br><span class="line"></span><br><span class="line">  sema_down (&amp;lock-&gt;semaphore);</span><br><span class="line">  lock-&gt;holder = thread_current ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有个sema_down函数调用了，我们继续看看sema_down函数的实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Down or "P" operation on a semaphore.  Waits for SEMA's value</span><br><span class="line">   to become positive and then atomically decrements it.</span><br><span class="line"></span><br><span class="line">   This function may sleep, so it must not be called within an</span><br><span class="line">   interrupt handler.  This function may be called with</span><br><span class="line">   interrupts disabled, but if it sleeps then the next scheduled</span><br><span class="line">   thread will probably turn interrupts back on. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">sema_down</span> <span class="params">(<span class="keyword">struct</span> semaphore *sema)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level;</span><br><span class="line"></span><br><span class="line">  ASSERT (sema != NULL);</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line"></span><br><span class="line">  old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">while</span> (sema-&gt;value == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      list_push_back (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem);</span><br><span class="line">      thread_block ();</span><br><span class="line">    &#125;</span><br><span class="line">  sema-&gt;value--;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果sema-&gt;value&gt;0，value就会递减，像lock的话value初始就是1，那么就只有一个线程可以占有lock，之后的进程调用lock_acquire的时候都会进入到循环里面，然后线程的elem就可以放到就会放到sema的等待队列中，接着调用了thread_block就会将进程变成等待的状态。</p>
<p>直到占有lock的线程调用了<code>lock_release</code><br>lock_release:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Releases LOCK, which must be owned by the current thread.</span><br><span class="line"></span><br><span class="line">   An interrupt handler cannot acquire a lock, so it does not</span><br><span class="line">   make sense to try to release a lock within an interrupt</span><br><span class="line">   handler. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">lock_release</span> <span class="params">(<span class="keyword">struct</span> lock *lock)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  ASSERT (lock != NULL);</span><br><span class="line">  ASSERT (lock_held_by_current_thread (lock));</span><br><span class="line"></span><br><span class="line">  lock-&gt;holder = NULL;</span><br><span class="line">  sema_up (&amp;lock-&gt;semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里其实很明显就是和lock_acquire还有sema_down是相对应的，我们继续来去看看sema_up<br>sema_up:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Up or "V" operation on a semaphore.  Increments SEMA's value</span><br><span class="line">   and wakes up one thread of those waiting for SEMA, if any.</span><br><span class="line"></span><br><span class="line">   This function may be called from an interrupt handler. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">sema_up</span> <span class="params">(<span class="keyword">struct</span> semaphore *sema)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level;</span><br><span class="line"></span><br><span class="line">  ASSERT (sema != NULL);</span><br><span class="line"></span><br><span class="line">  old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">if</span> (!list_empty (&amp;sema-&gt;waiters)) </span><br><span class="line">    thread_unblock (list_entry (list_pop_front (&amp;sema-&gt;waiters),</span><br><span class="line">                                <span class="keyword">struct</span> thread, elem));</span><br><span class="line">  sema-&gt;value++;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当释放锁时，如果锁中等待的队列不为空，那么就将队列中的第一个list_elem弹出，这里又见到了上面提到的list_entry了，所以我们知道得到的是弹出的list_elem对应的线程，然后这个进程unblock，就是将这个线程重新放到就绪队列中，接着value变回了1。</p>
<p>很好，然后我们就知道类似前面的使ready_list保持有序状态一样，我们让lock的wait_list也成为有序状态就好了。<br>具体实现就也是将list_push_back改为list_insert_ordered，然后函数也是用上面那个比较线程优先级就好了～<br>在sema_down中修改list_push_back函数，改为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_insert_ordered (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem, &amp;cmp_thread_priority, NULL);</span><br></pre></td></tr></table></figure></p>
<p>这个时候的样例输出就可以保证在main释放锁之后，acquire2在acquire1前面得到lock了。</p>
<p>然后我们来看看测试这个样例的输出，可以直接在终端下<code>$ pintos run priority-donate-one</code>看到<br><img src="/images/2015-07-04/priority-donate-one-1.png" alt="priority-donate-one-1"></p>
<p>很奇怪，为什么”acquire2: got the lock”会出现在”end”的后面？</p>
<p>首先我们来分析一下,”acquire2”出现了，而”acquire1”还没出现，说明我们这里处理的优先级是对的。我一开始以为一个线程给的tick运行的时间是很短的，线程马上就会切换，所以觉得很奇怪：acquire2的优先级比main高，所以这时候不是应该会抢夺过来了吗。。后来我上网查了一下才发现，这里的一个tick差不多可以跑10000次循环，所以要等到线程的正常切换是不可能的。而出现输出这样现象，我猜测是因为main运行的tick还没够，所以它会继续运行下面的代码，然后结束了主线程，而这时候的acquire2才从就绪队列中唤醒。</p>
<p>做了个小实验来验证一下，一次tick大概能做10000次循环，假设我们的优先级都是对的，那么我在实验样例测试源码中加入循环<br><img src="/images/2015-07-04/priority-donate-one-2.png" alt="priority-donate-one-testing"><br>然后我们单独地再测试一次priority-donate-one，就发现<br><img src="/images/2015-07-04/priority-donate-one-3.png" alt="priority-donate-one-testing1"><br>测试就pass了。这就说明我们的猜想是正确的。所以我们就在sema_up那里加一个<code>thread_yield</code>函数，有锁释放时，我们就要马上重新调度。</p>
<p>这个样例其实还不需要用到优先级捐赠，可以用来检测自己的lock_waiters优先级排序呀，锁释放后的进程切换呀相关这个基础代码没有问题了，再继续开始后面的。</p>
<p>接下来的才是donate最核心要关注的问题。</p>
<p>我们可以去看看donate测试系列的测试代码的注释<br>priority-donate-lower:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The main thread acquires a lock.  Then it creates a</span><br><span class="line">   higher-priority thread that blocks acquiring the lock, causing</span><br><span class="line">   it to donate their priorities to the main thread.  The main</span><br><span class="line">   thread attempts to lower its priority, which should not take</span><br><span class="line">   effect until the donation is released. */</span></span><br></pre></td></tr></table></figure></p>
<p>priority-donate-multiple:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The main thread acquires locks A and B, then it creates two</span><br><span class="line">   higher-priority threads.  Each of these threads blocks</span><br><span class="line">   acquiring one of the locks and thus donate their priority to</span><br><span class="line">   the main thread.  The main thread releases the locks in turn</span><br><span class="line">   and relinquishes its donated priorities.</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>priority-donate-nest:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Low-priority main thread L acquires lock A.  Medium-priority</span><br><span class="line">thread M then acquires lock B then blocks on acquiring lock A.</span><br><span class="line">High-priority thread H then blocks on acquiring lock B.  Thus,</span><br><span class="line">thread H donates its priority to M, which in turn donates it</span><br><span class="line">to thread L.</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>这里有提到几点：</p>
<ol>
<li>当释放锁时线程要放弃之前捐献的优先级，回到它自己的本身优先级上</li>
<li>如果线程在占有着锁时降低线程的优先级，这个降低的优先级不会影响到线程直到线程释放锁</li>
<li>捐献是具有可传递性的，当发生嵌套时，假设L线程占有A锁，M线程占有B锁在请求A锁，H线程在请求B锁，H线程的优先级就会先捐献给M线程，然后M线程就又捐献给L线程。</li>
<li>一个进程有多个锁的话将会以所有锁中的所有等待队列的线程中的最高优先级作为外显优先级</li>
</ol>
<p>第一，二点就要求我们的thread结构要有base_priority还有priority两个记录不同优先级的变量，一个是记录线程本身应有的优先级，一个是记录线程表现出来的优先级。</p>
<p>第三点要实现的话，我们就还要给每个thread加一个记录thread等待的lock的变量，虽然在第一层的时候可以通过lock的holder知道，但是往上的线程在等待的lock就不知道了。</p>
<p>第四点就要求thread结构体内还要有lock_list来记录这个线程所拥有的锁，这样才可以不断地挑出最高的优先级。</p>
<p>其实整个donate就一个比较大的部分要实现，那就是更新相关线程的优先级。要用到更新的地方有：有线程要加入waiter队列时，set_thread_priority中线程的优先级发生变化时，lock_release释放锁的时候</p>
<p>当然每个情况下都有细节要考虑的。</p>
<ol>
<li>加入waiter队列时：</li>
</ol>
<p>在lock_acquire中加入waiting_lock的设定<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">lock_acquire</span> <span class="params">(<span class="keyword">struct</span> lock *lock)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  ASSERT (lock != NULL);</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line">  ASSERT (!lock_held_by_current_thread (lock));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> thread* holder_thread = lock-&gt;holder;</span><br><span class="line">  <span class="keyword">if</span> (holder_thread != NULL) &#123;  <span class="comment">/* 这个锁已被占有 */</span></span><br><span class="line">    thread_current()-&gt;waiting_lock = lock;</span><br><span class="line">  &#125;</span><br><span class="line">  sema_down (&amp;lock-&gt;semaphore);</span><br><span class="line">  lock-&gt;holder = thread_current ();</span><br><span class="line">  list_push_back(&amp;lock-&gt;holder-&gt;lock_list, &amp;lock-&gt;elem); <span class="comment">/*  将这个锁的elem放到线程的lock_list中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在sema_down中调用更新优先级的函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">sema_down</span> <span class="params">(<span class="keyword">struct</span> semaphore *sema)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level;</span><br><span class="line"></span><br><span class="line">  ASSERT (sema != NULL);</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line"></span><br><span class="line">  old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">while</span> (sema-&gt;value == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      list_insert_ordered (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem, &amp;cmp_thread_priority, NULL);</span><br><span class="line">      <span class="keyword">if</span> (thread_current()-&gt;waiting_lock != NULL)  <span class="comment">//加入更新优先级函数</span></span><br><span class="line">        update_relative_threads_priority(thread_current()-&gt;waiting_lock-&gt;holder);</span><br><span class="line">      thread_block ();</span><br><span class="line">    &#125;</span><br><span class="line">  thread_current()-&gt;waiting_lock = NULL;</span><br><span class="line">  sema-&gt;value--;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更新优先级的函数实现先放一放，先把其他两个情况给考虑了。</p>
<ol>
<li>set_thread_priority那里直接加就好了</li>
<li>在释放锁时</li>
</ol>
<p>我们首先在lock_release中加入了remove_lock_from_holer_thread函数<br>就代表从current_thread中释放掉锁了。</p>
<p>remove_lock_from_holder_thread:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_lock_from_holder_thread</span><span class="params">(<span class="keyword">struct</span> lock* l)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> thread* holder_thread = l-&gt;holder;</span><br><span class="line">  list_remove(&amp;l-&gt;elem);</span><br><span class="line">  update_relative_threads_priority(holder_thread);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是从线程的lock_list中移除要释放的lock，然后再更新相关线程的优先级。</p>
<p>然后现在我们来讲一下更新相关线程优先级的函数<code>update_relative_threads_priority</code>的实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************</span><br><span class="line">name: update_relative_threads_priority</span><br><span class="line"></span><br><span class="line">Description: 根据现有线程的优先级，不断迭代更新在等待的资源的holder的优先级</span><br><span class="line"></span><br><span class="line">arguments: thread *</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_relative_threads_priority</span><span class="params">(<span class="keyword">struct</span> thread* a)</span> </span>&#123;</span><br><span class="line">  ASSERT(a != NULL);</span><br><span class="line">  <span class="keyword">while</span> (a != NULL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;a-&gt;lock_list)) &#123;</span><br><span class="line">        list_sort(&amp;a-&gt;lock_list, &amp;cmp_lock_list_priority, NULL); <span class="comment">//将lock_list中的对象按他们的优先级排序</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="built_in">list</span> *waiters = &amp;((list_entry(list_front(&amp;a-&gt;lock_list), <span class="keyword">struct</span> lock, elem))-&gt;semaphore.waiters);</span><br><span class="line">        <span class="keyword">int</span> newest_highest_priority = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(waiters)) &#123;</span><br><span class="line">           newest_highest_priority = list_entry(list_front(waiters), <span class="keyword">struct</span> thread, elem)-&gt;priority;  <span class="comment">//mark</span></span><br><span class="line">         &#125;</span><br><span class="line">        a-&gt;priority = newest_highest_priority &gt; a-&gt;base_priority?newest_highest_priority:a-&gt;base_priority;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a-&gt;priority = a-&gt;base_priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;waiting_lock != NULL)</span><br><span class="line">      a = a-&gt;waiting_lock-&gt;holder;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当输入的线程的lock_list不为空时，即a占有锁，这是为了保护list_sort里面的断言，然后就用list_sort排序，具体排序的判断函数是比较lock_list里面的elem所对应的lock的waiters队列中第一个线程的优先级，具体实现等下再讲。排好序后我们就可以从lock_list队列中弹出一个elem对应的lock的waiters队列，这个队列中含有最高的优先级的线程，然后就继续弹出等待队列的elem所对应的线程，然后这个线程的优先级就是我们想要的，和线程本身的优先级比较一下即可。在这个过程通过waiting_lock-&gt;holder进行下去，这个就保证了优先级的可传递性。</p>
<p>cmp_lock_list_priority的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************</span><br><span class="line"></span><br><span class="line">name: cmp_lock_list_priority</span><br><span class="line"></span><br><span class="line">Description: 比较lock_list里面的所有锁的最高优先级</span><br><span class="line"></span><br><span class="line">arguments: list_elem *a, list_elem *b, void *</span><br><span class="line"></span><br><span class="line">output: bool</span><br><span class="line"></span><br><span class="line">****************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_lock_list_priority</span><span class="params">(<span class="keyword">struct</span> list_elem *a, <span class="keyword">struct</span> list_elem *b, <span class="keyword">void</span> *aux)</span> </span>&#123;</span><br><span class="line">  ASSERT(a != NULL)</span><br><span class="line">  <span class="keyword">int</span> a_thread_priority, b_thread_priority;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a != NULL &amp;&amp; b != NULL) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">list</span> *a_lock_list = &amp;(list_entry(a, <span class="keyword">struct</span> lock, elem)-&gt;semaphore.waiters);</span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">list</span> *b_lock_list = &amp;(list_entry(b, <span class="keyword">struct</span> lock, elem)-&gt;semaphore.waiters);</span><br><span class="line"></span><br><span class="line">      a_thread_priority = !list_empty(a_lock_list)? list_entry(list_front(a_lock_list), <span class="keyword">struct</span> thread, elem)-&gt;priority:<span class="number">0</span>;</span><br><span class="line">      b_thread_priority = !list_empty(b_lock_list)? list_entry(list_front(b_lock_list), <span class="keyword">struct</span> thread, elem)-&gt;priority:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a_thread_priority &gt; b_thread_priority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成后测试一下<br><img src="/images/2015-07-04/priority-donate-result-1.png" alt="priority-donate-result-1"><br>还有一些细节要改进的</p>
<p>比如设置优先级还有sema_up</p>
<p><img src="/images/2015-07-04/priority-donate-improved-1.png" alt="priority-donate-improved-1"></p>
<p>再去跑一次</p>
<p><img src="/images/2015-07-04/priority-donate-result-2.png" alt="priority-donate-result-2"></p>
<p>还差一个！这个是有关condition的，和之前的sema类似，也是排一下序</p>
<p><img src="/images/2015-07-04/priority-donate-condvar.png" alt="priority-donate-condvar"></p>
<p>终于QAQ！！donate的做完了。</p>
<p>然后我们进入mlfqs部分的。这个部分的话，就是涉及多级反馈队列调度。</p>
<p>简单来说就是维持了64个队列，每个队列对应一个优先级，从PRI_MIN到PRI_MAX。然后通过一些公式计算来计算出线程当前的优先级，系统调度的时候会从高优先级队列开始选择线程执行，如果最高非空的优先级队列存在多个线程则使用轮转的方式在这多个线程中进行调度。值得注意的是，这里线程的优先级随着操作系统的运转数据而动态改变。</p>
<p>这个部分的文档比较详细。主要的部分在timer_interrupt里面根据tick的情况不一样，调用不同的更新函数。<br>在timer_interrupt中加入<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (thread_mlfqs) &#123;</span><br><span class="line">    update_recent_cpu_every_tick();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ticks%TIMER_FREQ == <span class="number">0</span>) &#123;</span><br><span class="line">      renew_load_avg();</span><br><span class="line">      renew_all_thread_recent_cpu();</span><br><span class="line">      renew_all_thread_priority();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ticks%<span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      renew_all_thread_priority();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后每个函数的具体实现在这里<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************</span><br><span class="line">name: renew_all_thread_recent_cpu</span><br><span class="line"></span><br><span class="line">Description: 将所有线程的recent_cpu都重新计算一次</span><br><span class="line"></span><br><span class="line">arguments: none</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew_all_thread_recent_cpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> list_elem *e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin (&amp;all_list); e != list_end (&amp;all_list);</span><br><span class="line">       e = list_next (e))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">struct</span> thread *t = list_entry (e, <span class="keyword">struct</span> thread, allelem);</span><br><span class="line">      <span class="keyword">if</span> (t != idle_thread)</span><br><span class="line">        renew_recent_cpu(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span><br><span class="line">name: renew_all_thread_priority</span><br><span class="line"></span><br><span class="line">Description: 将所有线程的recent_cpu都重新计算一次</span><br><span class="line"></span><br><span class="line">arguments: none</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew_all_thread_priority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> list_elem *e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin (&amp;all_list); e != list_end (&amp;all_list);</span><br><span class="line">       e = list_next (e))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">struct</span> thread *t = list_entry (e, <span class="keyword">struct</span> thread, allelem);</span><br><span class="line">      <span class="keyword">if</span> (t != idle_thread)</span><br><span class="line">        renew_thread_priority(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span><br><span class="line">name: renew_recent_cpu</span><br><span class="line"></span><br><span class="line">Description: 将线程的recent_cpu</span><br><span class="line">重新计算一次</span><br><span class="line"></span><br><span class="line">argement: struct thread *t</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew_recent_cpu</span><span class="params">(<span class="keyword">struct</span> thread *t)</span> </span>&#123;</span><br><span class="line">  t-&gt;recent_cpu = FP_ADD_MIX (FP_MULT (FP_DIV (FP_MULT_MIX (load_avg, <span class="number">2</span>), FP_ADD_MIX (FP_MULT_MIX (load_avg, <span class="number">2</span>), <span class="number">1</span>)), t-&gt;recent_cpu), t-&gt;nice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span><br><span class="line">name: renew_thread_priority</span><br><span class="line"></span><br><span class="line">Description: 将线程的priority</span><br><span class="line">重新计算一次</span><br><span class="line"></span><br><span class="line">argement: struct thread *t</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew_thread_priority</span><span class="params">(<span class="keyword">struct</span> thread *t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t == idle_thread)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  t-&gt;priority = FP_INT_PART (FP_SUB_MIX (FP_SUB (FP_CONST (PRI_MAX), FP_DIV_MIX (t-&gt;recent_cpu, <span class="number">4</span>)), <span class="number">2</span> * t-&gt;nice));</span><br><span class="line">  t-&gt;priority = t-&gt;priority &lt; PRI_MIN ? PRI_MIN : t-&gt;priority;</span><br><span class="line">  t-&gt;priority = t-&gt;priority &gt; PRI_MAX ? PRI_MAX : t-&gt;priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span><br><span class="line">name: renew_load_avg</span><br><span class="line"></span><br><span class="line">Description: 更新load_avg</span><br><span class="line"></span><br><span class="line">argement: none</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew_load_avg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  load_avg = FP_ADD (FP_DIV_MIX (FP_MULT_MIX (load_avg, <span class="number">59</span>), <span class="number">60</span>), FP_DIV_MIX (FP_CONST (get_all_ready_list_amount()), <span class="number">60</span>));;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，浮点计算的实现油鱼时间的关系，也是借鉴了一下网上的代码了QAQ<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef __THREAD_FIXED_POINT_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __THREAD_FIXED_POINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Basic definitions of fixed point. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> fixed_t;</span><br><span class="line"><span class="comment">/* 16 LSB used for fractional part. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_SHIFT_AMOUNT 16</span></span><br><span class="line"><span class="comment">/* Convert a value to fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_CONST(A) ((fixed_t)(A &lt;&lt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Add two fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_ADD(A,B) (A + B)</span></span><br><span class="line"><span class="comment">/* Add a fixed-point value A and an int value B. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_ADD_MIX(A,B) (A + (B &lt;&lt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Substract two fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_SUB(A,B) (A - B)</span></span><br><span class="line"><span class="comment">/* Substract an int value B from a fixed-point value A */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_SUB_MIX(A,B) (A - (B &lt;&lt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Multiply a fixed-point value A by an int value B. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_MULT_MIX(A,B) (A * B)</span></span><br><span class="line"><span class="comment">/* Divide a fixed-point value A by an int value B. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_DIV_MIX(A,B) (A / B)</span></span><br><span class="line"><span class="comment">/* Multiply two fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_MULT(A,B) ((fixed_t)(((int64_t) A) * B &gt;&gt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Divide two fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_DIV(A,B) ((fixed_t)((((int64_t) A) &lt;&lt; FP_SHIFT_AMOUNT) / B))</span></span><br><span class="line"><span class="comment">/* Get integer part of a fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_INT_PART(A) (A &gt;&gt; FP_SHIFT_AMOUNT)</span></span><br><span class="line"><span class="comment">/* Get rounded integer of a fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_ROUND(A) (A &gt;= 0 ? ((A + (1 &lt;&lt; (FP_SHIFT_AMOUNT - 1))) &gt;&gt; FP_SHIFT_AMOUNT) \</span><br><span class="line">        : ((A - (1 &lt;&lt; (FP_SHIFT_AMOUNT - 1))) &gt;&gt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* thread/fixed_point.h */</span></span><br></pre></td></tr></table></figure></p>
<p>但是跑出来的结果是mlqs部分全fail</p>
<p>其中，mlfqs-fair-2出来的结果是这样的<br><img src="/images/2015-07-04/mlfqs-problem.png" alt="mlfqs-problem"></p>
<p>里面跑出来的tick太少了，有可能是在timer_sleep中检测一个tick的时间是用忙等待的方法实现的，这样其实会使线程应得的tick数减低，我们要改进timer_sleep的等待方法,这里也是借鉴了一下网上的代码完成的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sleeps for approximately TICKS timer ticks.  Interrupts must</span><br><span class="line">   be turned on. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">timer_sleep</span> <span class="params">(<span class="keyword">int64_t</span> ticks)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ticks &lt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ASSERT (intr_get_level () == INTR_ON);</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">struct</span> thread *current_thread = thread_current ();</span><br><span class="line">  current_thread-&gt;blocked_ticks = ticks;</span><br><span class="line">  thread_block ();</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Timer interrupt handler. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">timer_interrupt</span> <span class="params">(<span class="keyword">struct</span> intr_frame *args UNUSED)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  ticks++;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level = intr_disable ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (thread_mlfqs) &#123;</span><br><span class="line">    update_recent_cpu_every_tick();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ticks%TIMER_FREQ == <span class="number">0</span>) &#123;</span><br><span class="line">      renew_load_avg();</span><br><span class="line">      renew_all_thread_recent_cpu();</span><br><span class="line">      renew_all_thread_priority();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ticks%<span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      renew_all_thread_priority();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  thread_foreach (blocked_thread_check, NULL);</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">  thread_tick ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the blocked thread */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">blocked_thread_check</span> <span class="params">(<span class="keyword">struct</span> thread *t, <span class="keyword">void</span> *aux UNUSED)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t-&gt;status == THREAD_BLOCKED &amp;&amp; t-&gt;blocked_ticks &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      t-&gt;blocked_ticks--;</span><br><span class="line">      <span class="keyword">if</span> (t-&gt;blocked_ticks == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          thread_unblock(t);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再去跑一次<br><img src="/images/2015-07-04/mlfqs-result.png" alt="mlfqs-result"></p>
<p>还有两个。其中一个mlfqs-load-avg.c中是这么说的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">If your implementation fails this test but passes most other</span><br><span class="line">   tests, then consider whether you are doing too much work in</span><br><span class="line">   the timer interrupt.  If the timer interrupt handler takes too</span><br><span class="line">   long, then the test's main thread will not have enough time to</span><br><span class="line">   do its own work (printing a message) and go back to sleep</span><br><span class="line">   before the next tick arrives.  Then the main thread will be</span><br><span class="line">   ready, instead of sleeping, when the tick arrives,</span><br><span class="line">   artificially driving up the load average.</span><br><span class="line">   */</span></span><br></pre></td></tr></table></figure></p>
<p>目测是我的timer interrupt里面做的东西太多了，可能是priority-donate那部分里面写的代码要改进一下，因为我之前在debug的时候发现在程序进行的时候会多次用到lock的，而我的donate部分实现的代码有点累赘，所以应该还是可以改进一下的。</p>
<p>但是因为要期末考复习了，所以就只能先到这里了QAQ。</p>
<h4 id="感想：">感想：</h4><p>因为这个project是在边复习边打的代码，所以完成得有点仓促，不过真的也在里面投入了很多的时间还有心血，起码有关线程部分里面的东西，我期末考不怎么担心了QAQ。我觉得其实这个实验还是挺有趣的，但是下次布置的时间可以再推前一点就更好了～毕竟，一边复习一边搞这个也是有点呛。嗯，本来想放到github上面的，中间做的过程可以看得清楚点，但是中间才想起来，前面的commit也补不上了，所以就不给地址了。而且因为报告是用的md写的，所以转成pdf的时候代码块有些地方可能就看不到了，这个就不好意思了QAQ。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/07/08/假期第一天/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          假期第一天
        
      </div>
    </a>
  
  
    <a href="/2015/05/25/2015-05-25-code-organization-and-object-oriented-programming/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">thinking code organization and object oriented programming</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Pintos-thread" data-title="Pintos_thread" data-url="http://dengal3.github.com/2015/07/04/Pintos-thread/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>



</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 ailin
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>