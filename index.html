<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ailin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ailin的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="ailin">
<meta property="og:url" content="http://dengal3.github.com/index.html">
<meta property="og:site_name" content="ailin">
<meta property="og:description" content="ailin的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ailin">
<meta name="twitter:description" content="ailin的博客">
  
    <link rel="alternative" href="/atom.xml" title="ailin" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/logo.jpg">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="images/logo.jpg" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ailin</a></h1>
		</hgroup>

		
		<p class="header-subtitle">其实这是流水账</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/dengal3" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/1793490742" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/dengal" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/hexo/" style="font-size: 10px;">hexo</a><a href="/tags/javascipt/" style="font-size: 10px;">javascipt</a><a href="/tags/javascript/" style="font-size: 10px;">javascript</a><a href="/tags/jekyll/" style="font-size: 10px;">jekyll</a><a href="/tags/object-oriented/" style="font-size: 10px;">object-oriented</a><a href="/tags/os/" style="font-size: 10px;">os</a><a href="/tags/pintos/" style="font-size: 20px;">pintos</a><a href="/tags/thinking/" style="font-size: 20px;">thinking</a><a href="/tags/thread/" style="font-size: 10px;">thread</a><a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a><a href="/tags/假期/" style="font-size: 10px;">假期</a><a href="/tags/外排序/" style="font-size: 10px;">外排序</a><a href="/tags/数据库/" style="font-size: 20px;">数据库</a><a href="/tags/日常/" style="font-size: 10px;">日常</a><a href="/tags/树结构索引/" style="font-size: 10px;">树结构索引</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://daixuan.me">DX的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://54017.github.io">017的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">你希望能看到什么?</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ailin</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="images/logo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">ailin</h1>
			</hgroup>
			
			<p class="header-subtitle">其实这是流水账</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/dengal3" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/1793490742" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="http://www.zhihu.com/people/dengal" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-假期第一天" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/08/假期第一天/" class="article-date">
  	<time datetime="2015-07-08T14:42:21.000Z" itemprop="datePublished">2015-07-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/08/假期第一天/">假期第一天</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>再不努力就要失业了，我是抱着这样的心态进入了这个暑假的第一天。</p>
<p>前端的东西多而杂，但我觉得基础真的是最重要的，所以假期目标：完成百度前段技术学院的任务，主要是我想系统地过一遍，然后里面在每个重要的专题下面都有相应的干货，感觉跟着的话应该还是不错的。</p>
<p>然后如果还有时间的话就看一下angular，或者看一下node，或者呃，如果有想法的话就自己搭个网站。</p>
<p>噢对了，还有准备自己的一份简历。</p>
<p>好咯，暑假开始:)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello,暑假"</span>);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/假期/">假期</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日常/">日常</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-Pintos-thread" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/04/Pintos-thread/" class="article-date">
  	<time datetime="2015-07-04T02:18:11.000Z" itemprop="datePublished">2015-07-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/04/Pintos-thread/">Pintos_thread</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在开始之前看了看<a href="http://wenku.baidu.com/view/3ecadb71f242336c1eb95ee1.html" target="_blank" rel="external">深入浅出pintos</a>，这里面有pintos用到的基本函数的说明，非常不错的。</p>
<h4 id="入门阶段">入门阶段</h4><p>根据TA在实验中给出的第一部分提示，实现alarm-multiple<br>嗯，因为TA在上面写得比较详细了。我就在这里略带一下,顺便看看整个程序走下来的思路就好了。</p>
<p>因为pintos这里有很多样例测试，一眼看过去的话，根本不知道何从下手，其实如果想比较快地知道这个样例测试的目的的话，有个比较快的方法：那就是看那个样例测试文件的前面的注释。</p>
<p>举个栗子:我想知道alarm-priority这个样例想让我们实现什么。那就打开<code>src/test/threads/alarm-priority.c</code><img src="/images/2015-07-04/alarm-priority.png" alt="alarm-priority"></p>
<p>然后综合一下样例对应的output还有result，就知道了这是希望我们当唤醒就绪列队中的线程时，我们总是让优先级高的线程先运行。</p>
<p>thread.c里有一个全局变量ready_list代表就绪线程，我们只要一直维持就绪线程有一个从高到低的优先级就好，在这里的话，主要就是在有ready_list的地方啦<br><img src="/images/2015-07-04/alarm-priority-1.png" alt="alarm-priority-1"><br><img src="/images/2015-07-04/alarm-priority-2.png" alt="alarm-priority-2"><br>这里主要是将list_push_back改为了list_insert_ordered，使队列成为有序的。我们要去看看list_insert_ordered的实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inserts ELEM in the proper position in LIST, which must be</span><br><span class="line">   sorted according to LESS given auxiliary data AUX.</span><br><span class="line">   Runs in O(n) average case in the number of elements in LIST. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">list_insert_ordered</span> <span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">struct</span> list_elem *elem,</span><br><span class="line">                     list_less_func *less, <span class="keyword">void</span> *aux)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> list_elem *e;</span><br><span class="line"></span><br><span class="line">  ASSERT (<span class="built_in">list</span> != NULL);</span><br><span class="line">  ASSERT (elem != NULL);</span><br><span class="line">  ASSERT (less != NULL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin (<span class="built_in">list</span>); e != list_end (<span class="built_in">list</span>); e = list_next (e))</span><br><span class="line">    <span class="keyword">if</span> (less (elem, e, aux))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">return</span> list_insert (e, elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要用到less函数作为排序的判断条件，这个是要我们自己实现的。这里要用到线程中的elem变量，还有list_entry，list_entry这个存在我觉得很有必要说清楚，因为之后在实现的过程中，这个东西就是起着很重要的作用。</p>
<p>一段有关list_entry的注释很好地解释了它的作用还有用法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Doubly linked list.</span><br><span class="line"></span><br><span class="line">   This implementation of a doubly linked list does not require</span><br><span class="line">   use of dynamically allocated memory.  Instead, each structure</span><br><span class="line">   that is a potential list element must embed a struct list_elem</span><br><span class="line">   member.  All of the list functions operate on these `struct</span><br><span class="line">   list_elem's.  The list_entry macro allows conversion from a</span><br><span class="line">   struct list_elem back to a structure object that contains it.</span><br><span class="line"></span><br><span class="line">   For example, suppose there is a needed for a list of `struct</span><br><span class="line">   foo'.  `struct foo' should contain a `struct list_elem'</span><br><span class="line">   member, like so:</span><br><span class="line"></span><br><span class="line">      struct foo</span><br><span class="line">        &#123;</span><br><span class="line">          struct list_elem elem;</span><br><span class="line">          int bar;</span><br><span class="line">          ...other members...</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">   Then a list of `struct foo' can be be declared and initialized</span><br><span class="line">   like so:</span><br><span class="line"></span><br><span class="line">      struct list foo_list;</span><br><span class="line"></span><br><span class="line">      list_init (&amp;foo_list);</span><br><span class="line"></span><br><span class="line">   Iteration is a typical situation where it is necessary to</span><br><span class="line">   convert from a struct list_elem back to its enclosing</span><br><span class="line">   structure.  Here's an example using foo_list:</span><br><span class="line"></span><br><span class="line">      struct list_elem *e;</span><br><span class="line"></span><br><span class="line">      for (e = list_begin (&amp;foo_list); e != list_end (&amp;foo_list);</span><br><span class="line">           e = list_next (e))</span><br><span class="line">        &#123;</span><br><span class="line">          struct foo *f = list_entry (e, struct foo, elem);</span><br><span class="line">          ...do something with f...</span><br><span class="line">        &#125;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>简单说来，list_entry就是一个很神奇的函数，你可以通过依次传入list_elem<em> elem，包含list_elem</em>的结构体，list_elem<em> 在结构体中的命名，来求出包含list_elem</em> elem对应的那个结构体的指针。</p>
<p>在less这个函数实现中elem是我们传的list<br>elem<em>,e是队列中的list_elem</em>,而我们想实现的是，如果elem的对应线程的优先级比e对应的线程的优先级要高时，就插到这个e的前面。具体代码实现如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************</span><br><span class="line">Function: cmp_thread_priority</span><br><span class="line"></span><br><span class="line">Description: 比较两个线程的优先级，如果前一个线程的优先级比后面的一个优先级高，则返回true，否则返回false</span><br><span class="line"></span><br><span class="line">Arguments: list_elem *, list_elem *, void *</span><br><span class="line"></span><br><span class="line">Output: bool</span><br><span class="line"></span><br><span class="line">************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_thread_priority</span> <span class="params">(<span class="keyword">struct</span> list_elem* a, <span class="keyword">struct</span> list_elem* b, <span class="keyword">void</span>* aux)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list_entry(a, <span class="keyword">struct</span> thread, elem)-&gt;priority &gt; list_entry(b, <span class="keyword">struct</span> thread, elem)-&gt;priority; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本来还有个地方是list_init(&amp;ready_list),这个不影响优先级的，所以不用改也ok。</p>
<p>然后我们就来<code>make clean</code>&amp;<code>make check</code>一下</p>
<p><img src="/images/2015-07-04/result-1.png" alt="result-1"></p>
<h4 id="正式开始">正式开始</h4><p>借着第一个测试样例的分析，我们来简单地过一下thread的基本知识还有函数。<br>首先，我们去看priority-change对应的测试样例代码（thread的测试样例代码都在<code>src/test/threads</code>文件夹下）<br><img src="/images/2015-07-04/priority-change.png" alt="priority-change"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">test_priority_change</span> <span class="params">(<span class="keyword">void</span>)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="comment">/* This test does not work with the MLFQS. */</span></span><br><span class="line">  ASSERT (!thread_mlfqs);</span><br><span class="line"></span><br><span class="line">  msg (<span class="string">"Creating a high-priority thread 2."</span>);</span><br><span class="line">  thread_create (<span class="string">"thread 2"</span>, PRI_DEFAULT + <span class="number">1</span>, changing_thread, NULL);</span><br><span class="line">  msg (<span class="string">"Thread 2 should have just lowered its priority."</span>);</span><br><span class="line">  thread_set_priority (PRI_DEFAULT - <span class="number">2</span>);</span><br><span class="line">  msg (<span class="string">"Thread 2 should have just exited."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">changing_thread</span> <span class="params">(<span class="keyword">void</span> *aux UNUSED)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  msg (<span class="string">"Thread 2 now lowering priority."</span>);</span><br><span class="line">  thread_set_priority (PRI_DEFAULT - <span class="number">1</span>);</span><br><span class="line">  msg (<span class="string">"Thread 2 exiting."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ASSERT代表断言，就是指这里的thread_mlfqs一定是false的，不然就会报错。断言有助于我们找出代码出bug 的地方。<br><code>thread_create</code>函数在thread.c函数中实现,是用来创建新进程的。里面传的参数依次是线程的名字，线程的优先级，还有线程执行的函数，辅助参数。</p>
<p>分析之后发现，代码里面通过调用了<code>thread_create</code>函数创建了新进程，而且新进程的优先级是PRI_DEFAULT+1，比主线程的PRI_DEFAULT的还要高，所以会在主线程输出”Creating a high-priority thread 2.” 之后有线程Thread 2输出的”Thread 2 now lowering priority.”。所以我们在<code>thread_create</code>这个函数里面加入<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (priority &gt; thread_current()-&gt;priority) &#123;</span><br><span class="line">      thread_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>thread_set_priority</code>将本来是优先级最高的线程的优先级降低后，该线程就要马上放弃，重新加入到就绪列表中排队，然后重新调度，来确保在运行的是所有就绪队列中优先级最高的那个。所以我们直接在<code>thread_set_priority</code>函数里面加入<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_yield();</span><br></pre></td></tr></table></figure></p>
<p>嗯,然后我们就可以看到结果了。<br><img src="/images/2015-07-04/result-2.png" alt="result-2"><br>这个一起把priority-preemt还有priority-fifo一起给过了，非常好～</p>
<p>然后就进入<strong>donate</strong>部分。<br>因为donate部分的实现是整个实验的重点和难点部分，所以会比较详细的解释。</p>
<p>首先我们要知道优先级捐赠是什么意思，这个的话TA在pdf中的解释也比较清楚了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">假设任务1，任务2，任务3；他们的优先级顺序分别为1 &lt; 2 &lt; 3。有一个稀缺资源S，S由一个锁控制为互斥访问。</span><br><span class="line"></span><br><span class="line">任务1正在执行，并申请到了资源S；</span><br><span class="line">任务3抢占了任务1的执行，任务1挂起，任务3执行；</span><br><span class="line">任务3申请资源S，发现被占用，所以挂起，任务1恢复执行；</span><br><span class="line">任务2抢占了任务1的执行，任务1挂起，任务2执行；</span><br><span class="line">任务2执行完毕，任务1恢复；</span><br><span class="line">任务1释放资源S，任务3抢占资源S，任务3执行，任务1挂起；</span><br><span class="line">任务3执行完毕，任务1执行。</span><br><span class="line">以上可以看出，任务2虽然比任务3优先级低，但是比任务3优先执行。也就是说任务3的优先级被降低到了任务1的级别。</span><br><span class="line"></span><br><span class="line">     如何解决这个问题呢？最简单的思路就是一旦高优先级的任务因为低优先级任务占用资源而阻塞时，就将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级。</span><br><span class="line"></span><br><span class="line">这样的话上述过程中的2不能抢占任务1的执行，也就不会发生优先级反转，上述过程就是我们所说的优先级捐赠。</span><br></pre></td></tr></table></figure></p>
<p>首先我们来看看<code>priority-donate-one.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The main thread acquires a lock.  Then it creates two</span><br><span class="line">   higher-priority threads that block acquiring the lock, causing</span><br><span class="line">   them to donate their priorities to the main thread.  When the</span><br><span class="line">   main thread releases the lock, the other threads should</span><br><span class="line">   acquire it in priority order.</span><br><span class="line"></span><br><span class="line">   Based on a test originally submitted for Stanford's CS 140 in</span><br><span class="line">   winter 1999 by Matt Franklin &lt;startled@leland.stanford.edu&gt;,</span><br><span class="line">   Greg Hutchins &lt;gmh@leland.stanford.edu&gt;, Yu Ping Hu</span><br><span class="line">   &lt;yph@cs.stanford.edu&gt;.  Modified by arens. */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "tests/threads/tests.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "threads/init.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "threads/synch.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "threads/thread.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> thread_func acquire1_thread_func;</span><br><span class="line"><span class="keyword">static</span> thread_func acquire2_thread_func;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">test_priority_donate_one</span> <span class="params">(<span class="keyword">void</span>)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> lock lock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This test does not work with the MLFQS. */</span></span><br><span class="line">  ASSERT (!thread_mlfqs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure our priority is the default. */</span></span><br><span class="line">  ASSERT (thread_get_priority () == PRI_DEFAULT);</span><br><span class="line"></span><br><span class="line">  lock_init (&amp;lock);</span><br><span class="line">  lock_acquire (&amp;lock);</span><br><span class="line">  thread_create (<span class="string">"acquire1"</span>, PRI_DEFAULT + <span class="number">1</span>, acquire1_thread_func, &amp;lock);</span><br><span class="line">  msg (<span class="string">"This thread should have priority %d.  Actual priority: %d."</span>,</span><br><span class="line">       PRI_DEFAULT + <span class="number">1</span>, thread_get_priority ());</span><br><span class="line">  thread_create (<span class="string">"acquire2"</span>, PRI_DEFAULT + <span class="number">2</span>, acquire2_thread_func, &amp;lock);</span><br><span class="line">  msg (<span class="string">"This thread should have priority %d.  Actual priority: %d."</span>,</span><br><span class="line">       PRI_DEFAULT + <span class="number">2</span>, thread_get_priority ());</span><br><span class="line">  lock_release (&amp;lock);</span><br><span class="line">  msg (<span class="string">"acquire2, acquire1 must already have finished, in that order."</span>);</span><br><span class="line">  msg (<span class="string">"This should be the last line before finishing this test."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">acquire1_thread_func</span> <span class="params">(<span class="keyword">void</span> *lock_)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> lock *lock = lock_;</span><br><span class="line"></span><br><span class="line">  lock_acquire (lock);</span><br><span class="line">  msg (<span class="string">"acquire1: got the lock"</span>);</span><br><span class="line">  lock_release (lock);</span><br><span class="line">  msg (<span class="string">"acquire1: done"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">acquire2_thread_func</span> <span class="params">(<span class="keyword">void</span> *lock_)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> lock *lock = lock_;</span><br><span class="line"></span><br><span class="line">  lock_acquire (lock);</span><br><span class="line">  msg (<span class="string">"acquire2: got the lock"</span>);</span><br><span class="line">  lock_release (lock);</span><br><span class="line">  msg (<span class="string">"acquire2: done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>样例代码调用了<code>lock_init (&amp;lock)</code>,我们去看看相关的具体实现，lock相关部分的代码都在synch.c中</p>
<p>我们先去看看lock的结构体，相关的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lock. */</span></span><br><span class="line"><span class="keyword">struct</span> lock </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> thread *holder;      <span class="comment">/* Thread holding lock (for debugging). */</span></span><br><span class="line">    <span class="keyword">struct</span> semaphore semaphore; <span class="comment">/* Binary semaphore controlling access. */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A counting semaphore. */</span></span><br><span class="line"><span class="keyword">struct</span> semaphore </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> value;             <span class="comment">/* Current value. */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">list</span> waiters;        <span class="comment">/* List of waiting threads. */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>lock里面有个holder指针指向占有这个锁的线程，semaphore是信号量，这里也给出了它的实现，semaphore中有一个value，还有一个链表来记录在等待这个锁的线程。</p>
<p>lock_init(顾名思义，就是lock的初始化)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initializes LOCK.  A lock can be held by at most a single</span><br><span class="line">   thread at any given time.  Our locks are not "recursive", that</span><br><span class="line">   is, it is an error for the thread currently holding a lock to</span><br><span class="line">   try to acquire that lock.</span><br><span class="line"></span><br><span class="line">   A lock is a specialization of a semaphore with an initial</span><br><span class="line">   value of 1.  The difference between a lock and such a</span><br><span class="line">   semaphore is twofold.  First, a semaphore can have a value</span><br><span class="line">   greater than 1, but a lock can only be owned by a single</span><br><span class="line">   thread at a time.  Second, a semaphore does not have an owner,</span><br><span class="line">   meaning that one thread can "down" the semaphore and then</span><br><span class="line">   another one "up" it, but with a lock the same thread must both</span><br><span class="line">   acquire and release it.  When these restrictions prove</span><br><span class="line">   onerous, it's a good sign that a semaphore should be used,</span><br><span class="line">   instead of a lock. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">lock_init</span> <span class="params">(<span class="keyword">struct</span> lock *lock)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  ASSERT (lock != NULL);</span><br><span class="line"></span><br><span class="line">  lock-&gt;holder = NULL;</span><br><span class="line">  sema_init (&amp;lock-&gt;semaphore, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里先将锁的占有者设为NULL，然后在调用了个sema_init函数,看看sema_init的实现</p>
<p>sema_init(对信号量的初始化)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initializes semaphore SEMA to VALUE.  A semaphore is a</span><br><span class="line">   nonnegative integer along with two atomic operators for</span><br><span class="line">   manipulating it:</span><br><span class="line"></span><br><span class="line">   - down or "P": wait for the value to become positive, then</span><br><span class="line">     decrement it.</span><br><span class="line"></span><br><span class="line">   - up or "V": increment the value (and wake up one waiting</span><br><span class="line">     thread, if any). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">sema_init</span> <span class="params">(<span class="keyword">struct</span> semaphore *sema, <span class="keyword">unsigned</span> value)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  ASSERT (sema != NULL);</span><br><span class="line"></span><br><span class="line">  sema-&gt;value = value;</span><br><span class="line">  list_init (&amp;sema-&gt;waiters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据刚刚lock传的值，就知道在lock_init中sema_init将sema的value设为了1</p>
<p>然后，我们看一下在synch.c中的<code>lock_acquire</code>函数具体实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Acquires LOCK, sleeping until it becomes available if</span><br><span class="line">   necessary.  The lock must not already be held by the current</span><br><span class="line">   thread.</span><br><span class="line"></span><br><span class="line">   This function may sleep, so it must not be called within an</span><br><span class="line">   interrupt handler.  This function may be called with</span><br><span class="line">   interrupts disabled, but interrupts will be turned back on if</span><br><span class="line">   we need to sleep. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">lock_acquire</span> <span class="params">(<span class="keyword">struct</span> lock *lock)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  ASSERT (lock != NULL);</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line">  ASSERT (!lock_held_by_current_thread (lock));</span><br><span class="line"></span><br><span class="line">  sema_down (&amp;lock-&gt;semaphore);</span><br><span class="line">  lock-&gt;holder = thread_current ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有个sema_down函数调用了，我们继续看看sema_down函数的实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Down or "P" operation on a semaphore.  Waits for SEMA's value</span><br><span class="line">   to become positive and then atomically decrements it.</span><br><span class="line"></span><br><span class="line">   This function may sleep, so it must not be called within an</span><br><span class="line">   interrupt handler.  This function may be called with</span><br><span class="line">   interrupts disabled, but if it sleeps then the next scheduled</span><br><span class="line">   thread will probably turn interrupts back on. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">sema_down</span> <span class="params">(<span class="keyword">struct</span> semaphore *sema)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level;</span><br><span class="line"></span><br><span class="line">  ASSERT (sema != NULL);</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line"></span><br><span class="line">  old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">while</span> (sema-&gt;value == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      list_push_back (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem);</span><br><span class="line">      thread_block ();</span><br><span class="line">    &#125;</span><br><span class="line">  sema-&gt;value--;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果sema-&gt;value&gt;0，value就会递减，像lock的话value初始就是1，那么就只有一个线程可以占有lock，之后的进程调用lock_acquire的时候都会进入到循环里面，然后线程的elem就可以放到就会放到sema的等待队列中，接着调用了thread_block就会将进程变成等待的状态。</p>
<p>直到占有lock的线程调用了<code>lock_release</code><br>lock_release:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Releases LOCK, which must be owned by the current thread.</span><br><span class="line"></span><br><span class="line">   An interrupt handler cannot acquire a lock, so it does not</span><br><span class="line">   make sense to try to release a lock within an interrupt</span><br><span class="line">   handler. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">lock_release</span> <span class="params">(<span class="keyword">struct</span> lock *lock)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  ASSERT (lock != NULL);</span><br><span class="line">  ASSERT (lock_held_by_current_thread (lock));</span><br><span class="line"></span><br><span class="line">  lock-&gt;holder = NULL;</span><br><span class="line">  sema_up (&amp;lock-&gt;semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里其实很明显就是和lock_acquire还有sema_down是相对应的，我们继续来去看看sema_up<br>sema_up:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Up or "V" operation on a semaphore.  Increments SEMA's value</span><br><span class="line">   and wakes up one thread of those waiting for SEMA, if any.</span><br><span class="line"></span><br><span class="line">   This function may be called from an interrupt handler. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">sema_up</span> <span class="params">(<span class="keyword">struct</span> semaphore *sema)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level;</span><br><span class="line"></span><br><span class="line">  ASSERT (sema != NULL);</span><br><span class="line"></span><br><span class="line">  old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">if</span> (!list_empty (&amp;sema-&gt;waiters)) </span><br><span class="line">    thread_unblock (list_entry (list_pop_front (&amp;sema-&gt;waiters),</span><br><span class="line">                                <span class="keyword">struct</span> thread, elem));</span><br><span class="line">  sema-&gt;value++;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当释放锁时，如果锁中等待的队列不为空，那么就将队列中的第一个list_elem弹出，这里又见到了上面提到的list_entry了，所以我们知道得到的是弹出的list_elem对应的线程，然后这个进程unblock，就是将这个线程重新放到就绪队列中，接着value变回了1。</p>
<p>很好，然后我们就知道类似前面的使ready_list保持有序状态一样，我们让lock的wait_list也成为有序状态就好了。<br>具体实现就也是将list_push_back改为list_insert_ordered，然后函数也是用上面那个比较线程优先级就好了～<br>在sema_down中修改list_push_back函数，改为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_insert_ordered (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem, &amp;cmp_thread_priority, NULL);</span><br></pre></td></tr></table></figure></p>
<p>这个时候的样例输出就可以保证在main释放锁之后，acquire2在acquire1前面得到lock了。</p>
<p>然后我们来看看测试这个样例的输出，可以直接在终端下<code>$ pintos run priority-donate-one</code>看到<br><img src="/images/2015-07-04/priority-donate-one-1.png" alt="priority-donate-one-1"></p>
<p>很奇怪，为什么”acquire2: got the lock”会出现在”end”的后面？</p>
<p>首先我们来分析一下,”acquire2”出现了，而”acquire1”还没出现，说明我们这里处理的优先级是对的。我一开始以为一个线程给的tick运行的时间是很短的，线程马上就会切换，所以觉得很奇怪：acquire2的优先级比main高，所以这时候不是应该会抢夺过来了吗。。后来我上网查了一下才发现，这里的一个tick差不多可以跑10000次循环，所以要等到线程的正常切换是不可能的。而出现输出这样现象，我猜测是因为main运行的tick还没够，所以它会继续运行下面的代码，然后结束了主线程，而这时候的acquire2才从就绪队列中唤醒。</p>
<p>做了个小实验来验证一下，一次tick大概能做10000次循环，假设我们的优先级都是对的，那么我在实验样例测试源码中加入循环<br><img src="/images/2015-07-04/priority-donate-one-2.png" alt="priority-donate-one-testing"><br>然后我们单独地再测试一次priority-donate-one，就发现<br><img src="/images/2015-07-04/priority-donate-one-3.png" alt="priority-donate-one-testing1"><br>测试就pass了。这就说明我们的猜想是正确的。所以我们就在sema_up那里加一个<code>thread_yield</code>函数，有锁释放时，我们就要马上重新调度。</p>
<p>这个样例其实还不需要用到优先级捐赠，可以用来检测自己的lock_waiters优先级排序呀，锁释放后的进程切换呀相关这个基础代码没有问题了，再继续开始后面的。</p>
<p>接下来的才是donate最核心要关注的问题。</p>
<p>我们可以去看看donate测试系列的测试代码的注释<br>priority-donate-lower:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The main thread acquires a lock.  Then it creates a</span><br><span class="line">   higher-priority thread that blocks acquiring the lock, causing</span><br><span class="line">   it to donate their priorities to the main thread.  The main</span><br><span class="line">   thread attempts to lower its priority, which should not take</span><br><span class="line">   effect until the donation is released. */</span></span><br></pre></td></tr></table></figure></p>
<p>priority-donate-multiple:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The main thread acquires locks A and B, then it creates two</span><br><span class="line">   higher-priority threads.  Each of these threads blocks</span><br><span class="line">   acquiring one of the locks and thus donate their priority to</span><br><span class="line">   the main thread.  The main thread releases the locks in turn</span><br><span class="line">   and relinquishes its donated priorities.</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>priority-donate-nest:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Low-priority main thread L acquires lock A.  Medium-priority</span><br><span class="line">thread M then acquires lock B then blocks on acquiring lock A.</span><br><span class="line">High-priority thread H then blocks on acquiring lock B.  Thus,</span><br><span class="line">thread H donates its priority to M, which in turn donates it</span><br><span class="line">to thread L.</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>这里有提到几点：</p>
<ol>
<li>当释放锁时线程要放弃之前捐献的优先级，回到它自己的本身优先级上</li>
<li>如果线程在占有着锁时降低线程的优先级，这个降低的优先级不会影响到线程直到线程释放锁</li>
<li>捐献是具有可传递性的，当发生嵌套时，假设L线程占有A锁，M线程占有B锁在请求A锁，H线程在请求B锁，H线程的优先级就会先捐献给M线程，然后M线程就又捐献给L线程。</li>
<li>一个进程有多个锁的话将会以所有锁中的所有等待队列的线程中的最高优先级作为外显优先级</li>
</ol>
<p>第一，二点就要求我们的thread结构要有base_priority还有priority两个记录不同优先级的变量，一个是记录线程本身应有的优先级，一个是记录线程表现出来的优先级。</p>
<p>第三点要实现的话，我们就还要给每个thread加一个记录thread等待的lock的变量，虽然在第一层的时候可以通过lock的holder知道，但是往上的线程在等待的lock就不知道了。</p>
<p>第四点就要求thread结构体内还要有lock_list来记录这个线程所拥有的锁，这样才可以不断地挑出最高的优先级。</p>
<p>其实整个donate就一个比较大的部分要实现，那就是更新相关线程的优先级。要用到更新的地方有：有线程要加入waiter队列时，set_thread_priority中线程的优先级发生变化时，lock_release释放锁的时候</p>
<p>当然每个情况下都有细节要考虑的。</p>
<ol>
<li>加入waiter队列时：</li>
</ol>
<p>在lock_acquire中加入waiting_lock的设定<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">lock_acquire</span> <span class="params">(<span class="keyword">struct</span> lock *lock)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  ASSERT (lock != NULL);</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line">  ASSERT (!lock_held_by_current_thread (lock));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> thread* holder_thread = lock-&gt;holder;</span><br><span class="line">  <span class="keyword">if</span> (holder_thread != NULL) &#123;  <span class="comment">/* 这个锁已被占有 */</span></span><br><span class="line">    thread_current()-&gt;waiting_lock = lock;</span><br><span class="line">  &#125;</span><br><span class="line">  sema_down (&amp;lock-&gt;semaphore);</span><br><span class="line">  lock-&gt;holder = thread_current ();</span><br><span class="line">  list_push_back(&amp;lock-&gt;holder-&gt;lock_list, &amp;lock-&gt;elem); <span class="comment">/*  将这个锁的elem放到线程的lock_list中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在sema_down中调用更新优先级的函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">sema_down</span> <span class="params">(<span class="keyword">struct</span> semaphore *sema)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level;</span><br><span class="line"></span><br><span class="line">  ASSERT (sema != NULL);</span><br><span class="line">  ASSERT (!intr_context ());</span><br><span class="line"></span><br><span class="line">  old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">while</span> (sema-&gt;value == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      list_insert_ordered (&amp;sema-&gt;waiters, &amp;thread_current ()-&gt;elem, &amp;cmp_thread_priority, NULL);</span><br><span class="line">      <span class="keyword">if</span> (thread_current()-&gt;waiting_lock != NULL)  <span class="comment">//加入更新优先级函数</span></span><br><span class="line">        update_relative_threads_priority(thread_current()-&gt;waiting_lock-&gt;holder);</span><br><span class="line">      thread_block ();</span><br><span class="line">    &#125;</span><br><span class="line">  thread_current()-&gt;waiting_lock = NULL;</span><br><span class="line">  sema-&gt;value--;</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更新优先级的函数实现先放一放，先把其他两个情况给考虑了。</p>
<ol>
<li>set_thread_priority那里直接加就好了</li>
<li>在释放锁时</li>
</ol>
<p>我们首先在lock_release中加入了remove_lock_from_holer_thread函数<br>就代表从current_thread中释放掉锁了。</p>
<p>remove_lock_from_holder_thread:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_lock_from_holder_thread</span><span class="params">(<span class="keyword">struct</span> lock* l)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> thread* holder_thread = l-&gt;holder;</span><br><span class="line">  list_remove(&amp;l-&gt;elem);</span><br><span class="line">  update_relative_threads_priority(holder_thread);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是从线程的lock_list中移除要释放的lock，然后再更新相关线程的优先级。</p>
<p>然后现在我们来讲一下更新相关线程优先级的函数<code>update_relative_threads_priority</code>的实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************</span><br><span class="line">name: update_relative_threads_priority</span><br><span class="line"></span><br><span class="line">Description: 根据现有线程的优先级，不断迭代更新在等待的资源的holder的优先级</span><br><span class="line"></span><br><span class="line">arguments: thread *</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">***************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_relative_threads_priority</span><span class="params">(<span class="keyword">struct</span> thread* a)</span> </span>&#123;</span><br><span class="line">  ASSERT(a != NULL);</span><br><span class="line">  <span class="keyword">while</span> (a != NULL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;a-&gt;lock_list)) &#123;</span><br><span class="line">        list_sort(&amp;a-&gt;lock_list, &amp;cmp_lock_list_priority, NULL); <span class="comment">//将lock_list中的对象按他们的优先级排序</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="built_in">list</span> *waiters = &amp;((list_entry(list_front(&amp;a-&gt;lock_list), <span class="keyword">struct</span> lock, elem))-&gt;semaphore.waiters);</span><br><span class="line">        <span class="keyword">int</span> newest_highest_priority = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(waiters)) &#123;</span><br><span class="line">           newest_highest_priority = list_entry(list_front(waiters), <span class="keyword">struct</span> thread, elem)-&gt;priority;  <span class="comment">//mark</span></span><br><span class="line">         &#125;</span><br><span class="line">        a-&gt;priority = newest_highest_priority &gt; a-&gt;base_priority?newest_highest_priority:a-&gt;base_priority;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a-&gt;priority = a-&gt;base_priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;waiting_lock != NULL)</span><br><span class="line">      a = a-&gt;waiting_lock-&gt;holder;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当输入的线程的lock_list不为空时，即a占有锁，这是为了保护list_sort里面的断言，然后就用list_sort排序，具体排序的判断函数是比较lock_list里面的elem所对应的lock的waiters队列中第一个线程的优先级，具体实现等下再讲。排好序后我们就可以从lock_list队列中弹出一个elem对应的lock的waiters队列，这个队列中含有最高的优先级的线程，然后就继续弹出等待队列的elem所对应的线程，然后这个线程的优先级就是我们想要的，和线程本身的优先级比较一下即可。在这个过程通过waiting_lock-&gt;holder进行下去，这个就保证了优先级的可传递性。</p>
<p>cmp_lock_list_priority的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************</span><br><span class="line"></span><br><span class="line">name: cmp_lock_list_priority</span><br><span class="line"></span><br><span class="line">Description: 比较lock_list里面的所有锁的最高优先级</span><br><span class="line"></span><br><span class="line">arguments: list_elem *a, list_elem *b, void *</span><br><span class="line"></span><br><span class="line">output: bool</span><br><span class="line"></span><br><span class="line">****************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_lock_list_priority</span><span class="params">(<span class="keyword">struct</span> list_elem *a, <span class="keyword">struct</span> list_elem *b, <span class="keyword">void</span> *aux)</span> </span>&#123;</span><br><span class="line">  ASSERT(a != NULL)</span><br><span class="line">  <span class="keyword">int</span> a_thread_priority, b_thread_priority;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a != NULL &amp;&amp; b != NULL) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">list</span> *a_lock_list = &amp;(list_entry(a, <span class="keyword">struct</span> lock, elem)-&gt;semaphore.waiters);</span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">list</span> *b_lock_list = &amp;(list_entry(b, <span class="keyword">struct</span> lock, elem)-&gt;semaphore.waiters);</span><br><span class="line"></span><br><span class="line">      a_thread_priority = !list_empty(a_lock_list)? list_entry(list_front(a_lock_list), <span class="keyword">struct</span> thread, elem)-&gt;priority:<span class="number">0</span>;</span><br><span class="line">      b_thread_priority = !list_empty(b_lock_list)? list_entry(list_front(b_lock_list), <span class="keyword">struct</span> thread, elem)-&gt;priority:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a_thread_priority &gt; b_thread_priority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成后测试一下<br><img src="/images/2015-07-04/priority-donate-result-1.png" alt="priority-donate-result-1"><br>还有一些细节要改进的</p>
<p>比如设置优先级还有sema_up</p>
<p><img src="/images/2015-07-04/priority-donate-improved-1.png" alt="priority-donate-improved-1"></p>
<p>再去跑一次</p>
<p><img src="/images/2015-07-04/priority-donate-result-2.png" alt="priority-donate-result-2"></p>
<p>还差一个！这个是有关condition的，和之前的sema类似，也是排一下序</p>
<p><img src="/images/2015-07-04/priority-donate-condvar.png" alt="priority-donate-condvar"></p>
<p>终于QAQ！！donate的做完了。</p>
<p>然后我们进入mlfqs部分的。这个部分的话，就是涉及多级反馈队列调度。</p>
<p>简单来说就是维持了64个队列，每个队列对应一个优先级，从PRI_MIN到PRI_MAX。然后通过一些公式计算来计算出线程当前的优先级，系统调度的时候会从高优先级队列开始选择线程执行，如果最高非空的优先级队列存在多个线程则使用轮转的方式在这多个线程中进行调度。值得注意的是，这里线程的优先级随着操作系统的运转数据而动态改变。</p>
<p>这个部分的文档比较详细。主要的部分在timer_interrupt里面根据tick的情况不一样，调用不同的更新函数。<br>在timer_interrupt中加入<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (thread_mlfqs) &#123;</span><br><span class="line">    update_recent_cpu_every_tick();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ticks%TIMER_FREQ == <span class="number">0</span>) &#123;</span><br><span class="line">      renew_load_avg();</span><br><span class="line">      renew_all_thread_recent_cpu();</span><br><span class="line">      renew_all_thread_priority();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ticks%<span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      renew_all_thread_priority();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后每个函数的具体实现在这里<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************************************</span><br><span class="line">name: renew_all_thread_recent_cpu</span><br><span class="line"></span><br><span class="line">Description: 将所有线程的recent_cpu都重新计算一次</span><br><span class="line"></span><br><span class="line">arguments: none</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew_all_thread_recent_cpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> list_elem *e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin (&amp;all_list); e != list_end (&amp;all_list);</span><br><span class="line">       e = list_next (e))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">struct</span> thread *t = list_entry (e, <span class="keyword">struct</span> thread, allelem);</span><br><span class="line">      <span class="keyword">if</span> (t != idle_thread)</span><br><span class="line">        renew_recent_cpu(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span><br><span class="line">name: renew_all_thread_priority</span><br><span class="line"></span><br><span class="line">Description: 将所有线程的recent_cpu都重新计算一次</span><br><span class="line"></span><br><span class="line">arguments: none</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew_all_thread_priority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> list_elem *e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (e = list_begin (&amp;all_list); e != list_end (&amp;all_list);</span><br><span class="line">       e = list_next (e))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">struct</span> thread *t = list_entry (e, <span class="keyword">struct</span> thread, allelem);</span><br><span class="line">      <span class="keyword">if</span> (t != idle_thread)</span><br><span class="line">        renew_thread_priority(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span><br><span class="line">name: renew_recent_cpu</span><br><span class="line"></span><br><span class="line">Description: 将线程的recent_cpu</span><br><span class="line">重新计算一次</span><br><span class="line"></span><br><span class="line">argement: struct thread *t</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew_recent_cpu</span><span class="params">(<span class="keyword">struct</span> thread *t)</span> </span>&#123;</span><br><span class="line">  t-&gt;recent_cpu = FP_ADD_MIX (FP_MULT (FP_DIV (FP_MULT_MIX (load_avg, <span class="number">2</span>), FP_ADD_MIX (FP_MULT_MIX (load_avg, <span class="number">2</span>), <span class="number">1</span>)), t-&gt;recent_cpu), t-&gt;nice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span><br><span class="line">name: renew_thread_priority</span><br><span class="line"></span><br><span class="line">Description: 将线程的priority</span><br><span class="line">重新计算一次</span><br><span class="line"></span><br><span class="line">argement: struct thread *t</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew_thread_priority</span><span class="params">(<span class="keyword">struct</span> thread *t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t == idle_thread)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  t-&gt;priority = FP_INT_PART (FP_SUB_MIX (FP_SUB (FP_CONST (PRI_MAX), FP_DIV_MIX (t-&gt;recent_cpu, <span class="number">4</span>)), <span class="number">2</span> * t-&gt;nice));</span><br><span class="line">  t-&gt;priority = t-&gt;priority &lt; PRI_MIN ? PRI_MIN : t-&gt;priority;</span><br><span class="line">  t-&gt;priority = t-&gt;priority &gt; PRI_MAX ? PRI_MAX : t-&gt;priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************</span><br><span class="line">name: renew_load_avg</span><br><span class="line"></span><br><span class="line">Description: 更新load_avg</span><br><span class="line"></span><br><span class="line">argement: none</span><br><span class="line"></span><br><span class="line">output: void</span><br><span class="line">****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew_load_avg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  load_avg = FP_ADD (FP_DIV_MIX (FP_MULT_MIX (load_avg, <span class="number">59</span>), <span class="number">60</span>), FP_DIV_MIX (FP_CONST (get_all_ready_list_amount()), <span class="number">60</span>));;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，浮点计算的实现油鱼时间的关系，也是借鉴了一下网上的代码了QAQ<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef __THREAD_FIXED_POINT_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> __THREAD_FIXED_POINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Basic definitions of fixed point. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> fixed_t;</span><br><span class="line"><span class="comment">/* 16 LSB used for fractional part. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_SHIFT_AMOUNT 16</span></span><br><span class="line"><span class="comment">/* Convert a value to fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_CONST(A) ((fixed_t)(A &lt;&lt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Add two fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_ADD(A,B) (A + B)</span></span><br><span class="line"><span class="comment">/* Add a fixed-point value A and an int value B. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_ADD_MIX(A,B) (A + (B &lt;&lt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Substract two fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_SUB(A,B) (A - B)</span></span><br><span class="line"><span class="comment">/* Substract an int value B from a fixed-point value A */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_SUB_MIX(A,B) (A - (B &lt;&lt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Multiply a fixed-point value A by an int value B. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_MULT_MIX(A,B) (A * B)</span></span><br><span class="line"><span class="comment">/* Divide a fixed-point value A by an int value B. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_DIV_MIX(A,B) (A / B)</span></span><br><span class="line"><span class="comment">/* Multiply two fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_MULT(A,B) ((fixed_t)(((int64_t) A) * B &gt;&gt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"><span class="comment">/* Divide two fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_DIV(A,B) ((fixed_t)((((int64_t) A) &lt;&lt; FP_SHIFT_AMOUNT) / B))</span></span><br><span class="line"><span class="comment">/* Get integer part of a fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_INT_PART(A) (A &gt;&gt; FP_SHIFT_AMOUNT)</span></span><br><span class="line"><span class="comment">/* Get rounded integer of a fixed-point value. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FP_ROUND(A) (A &gt;= 0 ? ((A + (1 &lt;&lt; (FP_SHIFT_AMOUNT - 1))) &gt;&gt; FP_SHIFT_AMOUNT) \</span><br><span class="line">        : ((A - (1 &lt;&lt; (FP_SHIFT_AMOUNT - 1))) &gt;&gt; FP_SHIFT_AMOUNT))</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* thread/fixed_point.h */</span></span><br></pre></td></tr></table></figure></p>
<p>但是跑出来的结果是mlqs部分全fail</p>
<p>其中，mlfqs-fair-2出来的结果是这样的<br><img src="/images/2015-07-04/mlfqs-problem.png" alt="mlfqs-problem"></p>
<p>里面跑出来的tick太少了，有可能是在timer_sleep中检测一个tick的时间是用忙等待的方法实现的，这样其实会使线程应得的tick数减低，我们要改进timer_sleep的等待方法,这里也是借鉴了一下网上的代码完成的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sleeps for approximately TICKS timer ticks.  Interrupts must</span><br><span class="line">   be turned on. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">timer_sleep</span> <span class="params">(<span class="keyword">int64_t</span> ticks)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ticks &lt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ASSERT (intr_get_level () == INTR_ON);</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level = intr_disable ();</span><br><span class="line">  <span class="keyword">struct</span> thread *current_thread = thread_current ();</span><br><span class="line">  current_thread-&gt;blocked_ticks = ticks;</span><br><span class="line">  thread_block ();</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Timer interrupt handler. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">timer_interrupt</span> <span class="params">(<span class="keyword">struct</span> intr_frame *args UNUSED)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  ticks++;</span><br><span class="line">  <span class="keyword">enum</span> intr_level old_level = intr_disable ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (thread_mlfqs) &#123;</span><br><span class="line">    update_recent_cpu_every_tick();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ticks%TIMER_FREQ == <span class="number">0</span>) &#123;</span><br><span class="line">      renew_load_avg();</span><br><span class="line">      renew_all_thread_recent_cpu();</span><br><span class="line">      renew_all_thread_priority();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ticks%<span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      renew_all_thread_priority();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  thread_foreach (blocked_thread_check, NULL);</span><br><span class="line">  intr_set_level (old_level);</span><br><span class="line">  thread_tick ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the blocked thread */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">blocked_thread_check</span> <span class="params">(<span class="keyword">struct</span> thread *t, <span class="keyword">void</span> *aux UNUSED)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t-&gt;status == THREAD_BLOCKED &amp;&amp; t-&gt;blocked_ticks &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      t-&gt;blocked_ticks--;</span><br><span class="line">      <span class="keyword">if</span> (t-&gt;blocked_ticks == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          thread_unblock(t);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再去跑一次<br><img src="/images/2015-07-04/mlfqs-result.png" alt="mlfqs-result"></p>
<p>还有两个。其中一个mlfqs-load-avg.c中是这么说的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">If your implementation fails this test but passes most other</span><br><span class="line">   tests, then consider whether you are doing too much work in</span><br><span class="line">   the timer interrupt.  If the timer interrupt handler takes too</span><br><span class="line">   long, then the test's main thread will not have enough time to</span><br><span class="line">   do its own work (printing a message) and go back to sleep</span><br><span class="line">   before the next tick arrives.  Then the main thread will be</span><br><span class="line">   ready, instead of sleeping, when the tick arrives,</span><br><span class="line">   artificially driving up the load average.</span><br><span class="line">   */</span></span><br></pre></td></tr></table></figure></p>
<p>目测是我的timer interrupt里面做的东西太多了，可能是priority-donate那部分里面写的代码要改进一下，因为我之前在debug的时候发现在程序进行的时候会多次用到lock的，而我的donate部分实现的代码有点累赘，所以应该还是可以改进一下的。</p>
<p>但是因为要期末考复习了，所以就只能先到这里了QAQ。</p>
<h4 id="感想：">感想：</h4><p>因为这个project是在边复习边打的代码，所以完成得有点仓促，不过真的也在里面投入了很多的时间还有心血，起码有关线程部分里面的东西，我期末考不怎么担心了QAQ。我觉得其实这个实验还是挺有趣的，但是下次布置的时间可以再推前一点就更好了～毕竟，一边复习一边搞这个也是有点呛。嗯，本来想放到github上面的，中间做的过程可以看得清楚点，但是中间才想起来，前面的commit也补不上了，所以就不给地址了。而且因为报告是用的md写的，所以转成pdf的时候代码块有些地方可能就看不到了，这个就不好意思了QAQ。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/os/">os</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pintos/">pintos</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-05-25-code-organization-and-object-oriented-programming" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/25/2015-05-25-code-organization-and-object-oriented-programming/" class="article-date">
  	<time datetime="2015-05-25T13:10:54.000Z" itemprop="datePublished">2015-05-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/25/2015-05-25-code-organization-and-object-oriented-programming/">thinking code organization and object oriented programming</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>星期天又重新改了一下ehelp的代码，现在暂时还没想好要怎么写，先写下些整理一下思路</p>
<ul>
<li>为什么又重构？<ul>
<li>之前是将私有变量放到实例对象中，但是prototype里面的方法全部都会暴露出来，<br> 这样的话私有变量其实会被修改的，这样其实是很不安全的。所以这次换成了IFFE方法封装<br> 可以选择性的返回你自己暴露的方法。</li>
<li>而且我发现这样有个优点就是：如果按之前的方法在prototype的方法里面调用prototype<br> 里面另一个方法的时候，这个时候其实处理起来挺麻烦的,这里好像又涉及到了一点js的基础问题<br> 这里要举例说明，不然以后可能会忘记自己在讲什么QAQ： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'private'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    constructor: A,</span><br><span class="line">    name: <span class="string">'prototype'</span>,</span><br><span class="line">    printIndirectly: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printDirectly();                 <span class="comment">//这里没有this的话会出错的</span></span><br><span class="line">    &#125;,</span><br><span class="line">    printDirectly: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">a.printIndirectly();                      <span class="comment">//private</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="开始讲故事：">开始讲故事：</h3><p>a在自己的<strong>私有</strong>的方法中没有找到printIndirectly方法，然后它就去顺着<strong>原型链</strong>去找，就找到了printIndirectly<strong>属性</strong>了，<br>(注意这里是<strong>属性</strong>)，相当于printIndirectly只是像一个指针一样的东西指向了一个匿名函数，然后我们就去调用这个函数，<br>不要忘记这时候我们的<strong>this还是</strong>，如果匿名函数里面没有this的话，是会报错说“printDirectly is not a function”的，因为这个<br>和这个对象的构造有密切的关系，上个图<br>        （明天上，今天很困，此处缺图一张）<br>其实可以这么说，在A里面所有属性指向的函数中都不能直接调用彼此的函数，因为他们所指向的匿名函数之间没有半毛钱关系，它们<br>就是通过各种属性被组装到了A.prototype这个对象里面。<br>而IFFE就不是这样的<br>        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'private'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">A.prototype = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> constructor = A;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'prototype'</span>;</span><br><span class="line">    <span class="keyword">var</span> printIndirectly = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            printDirectly.call(<span class="keyword">this</span>);               <span class="comment">//这里没有call的话，不报错，但会输出undefined</span></span><br><span class="line">    &#125;;                                           <span class="comment">//因为在printDirectly里面的this指向了window</span></span><br><span class="line">    <span class="keyword">var</span> printDirectly = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;            <span class="comment">//简直变化莫测（再见）</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        constructor: constructor,</span><br><span class="line">        printIndirectly: printIndirectly</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">a.printIndirectly();           <span class="comment">//private</span></span><br></pre></td></tr></table></figure></p>
<p>这里其实和上面的代码用的手法是不一样的。<br>上面的代码是通过this（即a）去访问printDirectly，而这里的代码确实可以在printIndirectly里面访问到<br>printDirectly的，只是这个时候我们需要自己固定好this的指向。<br>我觉得这里的代码的思想更好。</p>
<ul>
<li>一个是安全</li>
<li>一个就是内部访问内部的属性更方便</li>
<li>而且不需要多次搜索原型链</li>
<li>而且在写代码的过程中不需要多次去考虑this的指向问题（之前写的时候真是快想破我的脑袋了） </li>
</ul>
<p>当然这只是我个人的想法而已。因为代码部分还有涉及到闭包，异步的问题，这个就留着明天再讲</p>
<p>欲知后事如何，请听下回分解.zZ</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascipt/">javascipt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/object-oriented/">object-oriented</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thinking/">thinking</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/tech-diary/">tech-diary</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-05-24-install-pintos-on-ubuntu14-04" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/24/2015-05-24-install-pintos-on-ubuntu14-04/" class="article-date">
  	<time datetime="2015-05-24T15:05:46.000Z" itemprop="datePublished">2015-05-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/24/2015-05-24-install-pintos-on-ubuntu14-04/">install-pintos-on-ubuntu14.04</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="在ubuntu14-04下安装pintos">在ubuntu14.04下安装pintos</h2><h3 id="具体步骤">具体步骤</h3><ol>
<li>安装gcc,perl,make,autoconf,用<br><code>$ sudo apt-get intsall</code><br> 因为之前系统就装好了gcc，perl，make还有autoconf，所以这里都没有什么问题</li>
<li>然后就将下载的两个压缩包解压，得到bochs-2.6.7还有pintos两个文件夹</li>
<li>在终端下进入bochs-2.6.7文件夹<br> <img src="/images/2015-05-25/pintos0.png" alt="pic0"></li>
<li>设置bochs属性<br><code>$ ./configure --with-no-gui --enable-gdb-stub</code></li>
<li>在该目录下<br><code>$ sudo make install</code><br> <img src="/images/2015-05-25/pintos1.png" alt="pic1"></li>
<li>在当目录<code>$ bochs</code>,测试<br> <img src="/images/2015-05-25/pintos2.png" alt="pic2"><br> 这里出现了问题：大致的意思是指不能模拟出这个cpu</li>
<li>我们在当前目录下<code>$ bochs -help cpu</code>,然后就会看到有一列该bochs支持的cpu模式</li>
<li>这个时候我们就要<code>$ gedit .bochsrc</code>,将里面有一段是model：core2_penryn_t9600把后面一个换为刚刚列表显示</li>
<li>的一个，将刚刚的步骤重新来一遍</li>
<li>然后在再次<code>$ bochs</code>的时候你就会发现有lower sound support之类的错误出现。这个时候你就在目录下<br><code>$ ./configure --with-nogui --enable-gdb-stub --enable-sb16</code>，再次<code>$ sudo make install</code></li>
<li>这次就没有问题啦</li>
</ol>
<h3 id="bochs安装好了，现在开始pintos安装部分">bochs安装好了，现在开始pintos安装部分</h3><ol>
<li>进入~路径下<br><code>$ cd ~</code></li>
<li>编辑这个目录下的.profile文件，设置环境变量<br> <img src="/images/2015-05-25/pintos4.png" alt="pic4"></li>
<li>退出后<code>$ source .profile</code>,使.profile生效</li>
<li>在~下<code>$ pintos</code>,出来的结果为上面图的右边终端显示</li>
<li>这时候就进入pintos文件夹下的<code>src/util</code>,修改该目录下的<code>Makefile</code><br><img src="/images/2015-05-25/pintos5.png" alt="pic5"></li>
<li>保存后，执行<br><code>$ make</code></li>
<li>然后我们进入到<code>src/thread</code>的目录下，输入命令<code>$ make</code>,此时会产生<code>build</code>文件</li>
<li>进入<code>build</code>文件，执行<br><code>$ make check</code><br><img src="/images/2015-05-25/pintos6.png" alt="pic6"></li>
<li>然后执行<br><code>$ pintos run alarm-multiple</code><br><img src="/images/2015-05-25/pintos7.png" alt="pic7"></li>
</ol>
<h3 id="安装完成">安装完成</h3><h3 id="实验中遇到的问题">实验中遇到的问题</h3><p>好像TA教程没有写要设置config,但其实这个还是需要的，不然的话之后会有一个很<br>丑陋的gui，不过这也不是什么大问题，去bochs那里重新设置一下就好了</p>
<h3 id="实验心得">实验心得</h3><p>一切还是比较顺利的,并没有遇到什么大问题:)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pintos/">pintos</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ubuntu/">ubuntu</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/tech-diary/">tech-diary</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-05-23-thinking-code-organization" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/23/2015-05-23-thinking-code-organization/" class="article-date">
  	<time datetime="2015-05-22T16:00:00.000Z" itemprop="datePublished">2015-05-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/23/2015-05-23-thinking-code-organization/">javascript模块化编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前两天重构了一下ehelp的地图页面的代码，用对象来封装了一下方法。<br><a href="https://github.com/dengal3/ehelp/blob/gh-pages/amap-api-first-try.js" target="_blank" rel="external">代码链接</a><br>但是我今天发现这个代码其实还是比较糟糕的，滥用了闭包，而且在每次添加新的方法的时候都要考虑this，<br>这就说明代码有比较大的问题，仍然需要重构。<br>在想新的重构过程中也搜索了一下，下面也有一些有关模块化思想：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="external">Javascript模块化编程（一）：模块的写法</a></li>
<li><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="external">JavaScript-Module-Pattern-In-Depth</a></li>
<li><a href="http://learn.jquery.com/code-organization/concepts/" target="_blank" rel="external">Code Organization Concepts</a></li>
</ul>
<p>对ehelp的地图页面代码的第一次重构：</p>
<ul>
<li>提高部分： <ul>
<li>对js的闭包认识深刻了很多</li>
<li>第一次尝试模块化的编程</li>
</ul>
</li>
<li>不足：<ul>
<li>感觉代码的构架还是不够好（我发现EricWang说的TOP思想真的很难QAQ）</li>
</ul>
</li>
</ul>
<p>（ps:我感觉我这个代码要重构好多次QAQ 什么时候才可以开始下一个页面呢）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thinking/">thinking</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/tech-diary/">tech-diary</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-05-09-notes-dataBase-ch13" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/09/2015-05-09-notes-dataBase-ch13/" class="article-date">
  	<time datetime="2015-05-08T16:00:00.000Z" itemprop="datePublished">2015-05-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/09/2015-05-09-notes-dataBase-ch13/">数据库笔记--ch13 外排序</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>为什么需要排序？  数据库中很多操作都需要排序，比如用户需要按一定的次序返回查询结果等等<br>为什么要外排序？  因为数据庞大，当需要排序的数据大到主存无法容纳的时候，就需要采用外排序算法，减少磁盘访问的开销。</p>
<h2 id="简单的两路归并排序算法">简单的两路归并排序算法</h2><p>段：有序的子文件（段的概念感觉比页要大）<br>当主存不能容纳整个文件是，可以把文件划分为规模较小的子文件，首先对每个子文件进行排序，然后将排序后的子文件合并。假设输入文件的数据页数为2^k，那么第0遍处理生成2^k个长位1个数据页的有序段；第1遍处理生成2^k-1个长位2个数据页的有序段…</p>
<p>每遍的处理是读入一个数据页，处理，然后写回磁盘。因此对每个数据页需要读写磁盘两次。</p>
<h2 id="外归并排序">外归并排序</h2><p>对两路归并排序算法有两个重要改进：</p>
<ol>
<li>第0遍的处理，每次读入B个数据页，在主存内排序胡生成[N/B]个长为B个数据页的段（两路归并排序中是对每个数据页里面的数进行排序，没有合并的操作,所以出来的段数还是N）</li>
</ol>
<p>2 .采取（B-1）路归并，总的遍数位[logB-1 N]+1,两路算法的就是[log2 N]+1，而且B通常较大。<br>（疑问：为什么第0遍的时候就可以用B页，之后的都是B-1页，然后有一页用来做输出，难道一开始的时候不需要有页作为输出吗？是和归并算法有关吗？输出的那页到底是怎样的角色？）</p>
<p>替换排序算法：一个输入缓冲区，一个输出缓冲区，其余都是当前集，要求只要当前集中有K值比输出缓冲区的最大的那个K值大，就得继续从当前集读到输出缓冲区中，造成的空白位由输入缓冲区的一组填上。</p>
<h3 id="改进外排序算法：">改进外排序算法：</h3><h4 id="块I/O：">块I/O：</h4><p>  读写的单位变为了缓冲区块，就是说每次读写的数据页的数目变多的话，我们就可以尽量减少对数据处理的遍数，因为算法每遍处理都要读写每个数据页。但是这里有个问题就是，我们选择打的缓冲区块的划，每次归并的<br>（疑问：缓冲区和页的大小有关吗？每次的读写的怎样的？按页读写？那当段大于一页的时候是怎样操作的？）</p>
<h4 id="双缓冲：">双缓冲：</h4><p>因为当缓冲区块的元组用完时，就要去读入当前序段的下一个缓冲区块，这时候的CPU就空闲状态。<br>解决方法：为每个输入缓冲区分配额外的缓冲区页，当一个区块被读完时CPU的就去读另一个区块的，同时发送I/O请求，读取下一个缓冲区块。</p>
<h2 id="用B+树来排序">用B+树来排序</h2><p>聚簇索引—-推荐用B+树排序<br>非聚簇索引—-不建议，还不如用外排序算法做</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/外排序/">外排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/笔记/">笔记</a><a class="article-category-link" href="/categories/笔记/数据库/">数据库</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-05-09-notes-dataBase-ch10" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/09/2015-05-09-notes-dataBase-ch10/" class="article-date">
  	<time datetime="2015-05-08T16:00:00.000Z" itemprop="datePublished">2015-05-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/09/2015-05-09-notes-dataBase-ch10/">数据库笔记---ch10 树结构索引</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="纵观">纵观</h1><p>树结构索引的好处：定位记录的I/O减少，索引树的高度一般就是3,4层<br>树结构中的两种结构</p>
<pre><code><span class="bullet">1.  </span>ISAM结构
<span class="bullet">2.  </span>B+树结构
</code></pre><h2 id="ISAM结构（索引顺序存取方法）">ISAM结构（索引顺序存取方法）</h2><ol>
<li>索引树的结构不变，是静态的</li>
<li>多个项插入到一个叶子页，超出了一页，就需要分配另外的页，加入溢出页（这是从溢出区中分配出来的）</li>
</ol>
<h3 id="搜索的过程：">搜索的过程：</h3><p>搜索的数据和索引中的值比较，一层层下去，到达叶子（数据页），然后在主叶子页中搜索，没有的话就去主叶子页对应的溢出页中搜索。</p>
<h3 id="缺点：">缺点：</h3><ol>
<li>如果大量的插入操作作用于同一叶子，就会产生很长的溢出页链，这些链非常影响搜索记录的时间。</li>
</ol>
<h3 id="优点：">优点：</h3><ol>
<li>只有叶子叶被修改对于并发访问也有好处。当一页被访问时，会被申请者锁定，保证它不被该页的其他用户并发修改。</li>
<li>索引级的页从不被修改，可以不对索引级页加锁（这是优于B+的一个重要优点）</li>
<li>当数据分布和大小相对稳定而使得溢出链很少时，ISAM将优于B+树</li>
</ol>
<h2 id="B+树（动态索引结构）">B+树（动态索引结构）</h2><ol>
<li>平衡树</li>
<li>叶子页之间用双向链表</li>
<li>只有索引级树和叶子级树（即和ISAM相比，没有溢出页）</li>
<li>每个节点都要保证最少50%的占有率（假设，每个节点包含m个项的B+树，其中d&lt;=m&lt;=2d，d是B+树的一个参数，秩。根节点是唯一的例外1&lt;=m&lt;=2d）</li>
</ol>
<h3 id="节点格式">节点格式</h3><p>有m个索引项的非叶子页节点包含m+1个指向孩子的指针。叶子页以双向链表的形式连接起来。</p>
<p>（有关搜索，插入和删除的操作，B+都不允许重复）</p>
<h5 id="搜索">搜索</h5><p>在索引树上缩小范围后，通过指针访问叶子页，然后继续通过双向链表进行搜索</p>
<h3 id="插入">插入</h3><p>注意分裂的问题，因为B+不加入溢出页，当插入的数据多于一个页都可以存放的量的时候，就需要分裂叶子页，这里分裂叶子页过程是这样的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/452608-f1ce4a9d58edff90.png" alt="2015-05-07 19:32:02 的屏幕截图.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/452608-a9eb58c432cffb12.png" alt="2015-05-07 19:32:25 的屏幕截图.png"><br>新插入的8使得新加了一页，因为每一页都会有索引指针指向，这就意味这我们要新增索引项，即复制了5的那项。这一项将会插到父节点中，因为父节点又满了，这就以为这父节点又要分裂。但是这里的分裂和刚刚的分裂优点不一样。新的项（5的那项）‘弹上去’以后，父节点要分裂，这时候的中间的那项17是被‘拉上去’而不是复制的。因为我们这时候不需要副本。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/452608-17014363dc5ee226.png" alt="2015-05-07 19:37:16 的屏幕截图.png"></p>
<p>这里也有个变种的方法：就是重分布，搜索兄弟节点检查是否还有空位插入。这个想法同样使用于删除中。</p>
<h3 id="删除">删除</h3><p>删除需要注意到合并的问题。开始时先考虑是否可以重分布，即搜索兄弟节点看是否可以‘过继’过来。如果不行的话，我们就要对两个节点进行合并（注意：合并就代表有页要被删除，这就代表着指针将会减少，父节点可能要被‘拉下来’）<br><img src="http://upload-images.jianshu.io/upload_images/452608-30ff34325acd2e9e.png" alt="2015-05-07 20:08:07 的屏幕截图.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/452608-b247f1ee33cadf91.png" alt="2015-05-07 20:07:09 的屏幕截图.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/452608-181d014cb98e39fa.png" alt="2015-05-07 20:07:34 的屏幕截图.png"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/树结构索引/">树结构索引</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/笔记/">笔记</a><a class="article-category-link" href="/categories/笔记/数据库/">数据库</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-05-09-about-hexo" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/09/2015-05-09-about-hexo/" class="article-date">
  	<time datetime="2015-05-08T16:00:00.000Z" itemprop="datePublished">2015-05-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/09/2015-05-09-about-hexo/">hexo在github搭建博客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 因为之前的jekyll的主题被人吐槽了，所以做烦了数据库之后，决定去给博客换个主题。然后顺便看了一下hexo，发现hexo比jekyll还要简单很多，而且主题页面页很简洁，感觉很不错，就用hexo重新做了。</p>
<h2 id="关键步骤:">关键步骤:</h2><ol>
<li><p>通过npm全局安装hexo</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -<span class="keyword">g</span> hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果之后想在本地调试的话就要装hexo-server,要部署到git上面的话就要装hexo-deployer,这可能和网上的一些教程不一样，因为那些<br> 教程是hexo2的，hexo3的server命令选项和一些其他的模块是要分开下的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm <span class="operator"><span class="keyword">install</span> hexo-deployer-git hexo-<span class="keyword">server</span> -save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化一个hexo项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> init</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你现在迫不及待，如狼似虎地想看看你的博客</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">$hexo</span> <span class="keyword">g</span>             <span class="comment">//hexo generate  生成代码</span></span><br><span class="line">$ hexo s            <span class="comment">//hexo server      部署到localhost:4000</span></span><br><span class="line">                        <span class="comment">// 如果你发现你没有这个命令的话 你很有可能是没有装hexo-server模块</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>你还可以换换主题，hexo有很多很棒的主题的<a href="http://www.zhihu.com/question/24422335" target="_blank" rel="external">戳我，我是任意门</a></p>
<p> 一般主题的github下的readme都有讲怎么做的，但我再详细讲一下好了<br> 其实当你hexo init的时候，就会发现你的目录下面多了一个’themes’的文件夹，里面有一个’landscape’,这个是<br> hexo的默认主题，如果你现在想换yilia主题的话,你先回到上级目录</p>
 <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> ..</span><br><span class="line"><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/litten</span><span class="regexp">/hexo-theme-yilia.git themes/yilia</span></span><br></pre></td></tr></table></figure>
<p> 然后你发现你的themes目录下多了一个yilia，但是现在还不行，你要需要去hexo项目的目录下（记住，这很重要）去修改_’config.yml’中的theme，<br> 把landscape改为yilia</p>
</li>
<li><p>然后你可能兴高采烈地去看localhost:4000，但你发现页面没有变，这里有个就是如果你改了’_config.yml’，最好是在下次看页面之前</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean                    <span class="comment">//清除刚刚生成的文件</span></span><br><span class="line">$ hexo <span class="keyword">g</span>                          <span class="comment">//重新生成文件</span></span><br><span class="line">$ hexo s                          <span class="comment">//再次开启localhost:4000端口的大门</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>你很开心地发现页面变了，然后你决定去写一篇意味深长的博文告诉世人你有博客啦，这时候，你就可以</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> new post <span class="string">"i have a dream"</span>           \\其实自己去<span class="built_in">source</span>目录下命名也可以，加上日期的话就可以排序</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后你写好了博客，要推到github上面（记住上面的hexo-deployer-git模块你已经安装好了）,这时你去刚刚改了theme的那个_config.yml的文件下</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:yourgithubname/yourgithubname.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>非常好，然后你就</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo deploy</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>然后像git push的时候一样把你的name，password输进去就好了</p>
<p>终于讲完了（不用谢:)）</p>
<p> 给个链接：<br> <a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br> <a href="http://forsweet.github.io/2015/04/20/%E7%94%A8Hexo%E6%90%AD%E5%BB%BAGithub%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">用Hexo 3 搭建github blog</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/博客搭建/">博客搭建</a><a class="article-category-link" href="/categories/博客搭建/日记/">日记</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-2015-05-07-about-jeklly" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/07/2015-05-07-about-jeklly/" class="article-date">
  	<time datetime="2015-05-06T16:00:00.000Z" itemprop="datePublished">2015-05-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/07/2015-05-07-about-jeklly/">jekyll以及主题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>jekyll整体的框架比较简单明了，官网说得也比较清楚。链接： <a href="http://jekyllrb.com/" target="_blank" rel="external">官网</a>，还有一个是<a href="http://jekyllcn.com/" target="_blank" rel="external">中文的网站</a></p>
<p>jekyll的主题也有很多，链接:<a href="http://jekyllcn.com/docs/sites/" target="_blank" rel="external">友情链接</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jekyll/">jekyll</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/博客搭建/">博客搭建</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 ailin
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>